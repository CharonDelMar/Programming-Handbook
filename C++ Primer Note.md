## Introduction ##
C++语言可以看作是三部分构成：低级语言、现代高级语言（允许我们定义自己的类型以及组织大规模程序和系统）、标准库（利用高级特性来提供有用的数据结构和算法）。

一个或多个函数 , 其中一个必须命名为 *main.* *main* 的返回值类型必须为 *int*, 一般被用于指示程序运行状态，返回值0代表成功，非0通常用于指示错误类型。

函数定义包含四个部分：return type, function name, parameter list & function body.

运行VS编译器命令：
系统提示符> c1 /编译器选项 源文件名
e.g. (std::C:\\Users\\me\\Programs>c1 /EHsc prog1.cpp)

C++是一种静态类型语言，其含义是*在编译阶段检查类型*。

通常情况下，C++的缩进格式不会影响程序的语义。

C++ 中，一个表达式产生一个运算结果，它由一个或多个运算对象和（通常情况下）一个运算符组成。

C++利用一个标准库来提供io机制。

**iostream library**

One *istream* object：cin (pron: see-in) 标准输入语法
Three *ostream* object：cout (pron: see-out) 标准输出语法、cerr 输出警告和错误消息、clog 输出程序运行时的一般信息

*IO操作一般只作用于当前运行窗口*

\>> 输入运算符 \<< 输出运算符

标准库定义的所有名字都在命名空间std中。*命名空间你可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突*，:: 为作用运算符来指名使用命令所在的命名空间。e.g. cout和endl定义在名为std的命名空间，所以调用时一般使用std : : cout和std : : endl。
>endl为一个被称为manipulator的特殊值，写入endl的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。**缓冲刷新操作可以保证到目前为止程序所产生的扫有输出都真正写入输出流中，而不是进停留在内存中等待写入流。**
  >>*程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。*


Comments: 单行注释 //    多行注释  /* \*/

循环结构：while for
使用一个*istream*对象作为条件时，其效果是**检测流的状态**。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符*end-of-file*，或者遇到一个无效输入时，*istream*对象的状态会变为无效。处于无效状态的*istream*对象会使条件变为假。
其应用形式类似于：(std:: while ( std : : cin >> value ))
>对于Windows系统，从键盘输入文件结束符的方式为 (std:: Ctrl +Z )
>对于macOX系统，从键盘输入文件结束符的方式为 (std:: Ctrl +D)

### Datatype (More Details in **Data Structure** ) ###

*当明确知晓数值不可能为负时，选用无符号类型*
*执行浮点数运算选用double*
*当一个算数表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。从无符号数中减去一个值时，我们要保证结果不可能为负。*

关于一些强行类型转换：
>非布尔类型的算数值 >> bool：初始值为0则结果为false，否则结果为true。
>bool >> 非布尔类型：初始值为false则结果为0, 初始值为true则结果为1。
>浮点数 >> int：结果仅保留小数点以前的部分。
>int >> 浮点数：小数部分记为0。若int所占空间超过浮点数则可能损失精度。
>unsigned >> 超出其表示范围的值，结果是初始值对无符号类型表示数值总数**取模**后的余数
>signed >> 超出其表示范围的值，结果未知，程序可能正常工作/崩溃/生成垃圾数据。

如果两个字符串字面值位置紧邻且仅有空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式，e.g.：
(std:: std : : cout << "a really, really long string literal")
                 (std:: "that spans two lines" << std : : endl; )

C++可以通过给字面值字符添加前后缀指定字面值类型；

转义字符（详见C++ documentation --> escape sequence）

## Variables ###

*初始化不是赋值！！！初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，然后用一个新值来代替。*

#### Initialisation ####

C++定义了多种初始化形式。

#### 列表初始化 ####

使用花括号初始化变量，e.g. (std:: int units_sold{0};)

 *当用于内置类型的变量时，如果我们使用列表初始化且存在丢失信息的风险，则编译器将报错。*
```
long double ld = 3.1415936;
int a{ld}, b = {ld};
int c(ld), d = ld;
```

#### 数组初始化 ####

允许使用数组来初始化vector对象。要实现这一目的，只需要指明要拷贝区域的首元素地址和尾后地址就可以了：
```
int int_arr[] = {0,1,2,3,4,5};
vector<int> ivec(begin(int_arr),end(int_arr));
```
#### 默认初始化 ####

如果定义变量时没有指定初始值，则变量被默认初始化，此时变量被赋予了default value。default value到底是什么由变量类型决定并受到定义变量的位置的影响。
如果是内置类型变量未被初始化，它的值一般由定义的位置决定。但是 *定义在函数体内部的内置类型变量将不被初始化。如果试图拷贝或以其他形式访问此类型将引发错误。*

每个类各自决定其初始化对象的方式，而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么 （*类的对象如果没有显式初始化，则其类型由类本身决定。*）。
绝大多数类都支持无须显式初始化而定义对象。
e.g.: (std:: std : : string empty // empty 非显式地初始化为一个空串。)
若不支持此功能的类的对象没有进行显式初始化，则程序会报错。

#### Declaration  & Definition ####

声明规定了变量的类型和名字；
定义规定了变量的类型和名字，申请存储空间，还可能为变量赋一个初值。

*如果想声明一个变量而不是定义它，需要使用 extern，且 **不要显式地初始化变量！！！*** 
```
extern int i; \\ Declaration
int j; \\ Definition
extern int k = 1; \\ Definition
```

*变量能且只能被定义一次，但可以被多次声明。* 如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现且只能出现在同一个文件中，而其他使用该变量的文件必须对其进行声明，**却决不能重复定义** 。

多数情况下可以等价使用不同的初始化方式，几种例外情况是：
1. 使用拷贝初始化时（即使用=时），只能提供一个初始值；
2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化；
3. 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里：
```
vector <string> v1{"a", "an", "the"}; // √
vector <string> v2("a", "an", "the"); // x
```
#### 作用域 Scope ####

```
int reused = 42; \\ [A] --> global scope
int main(){

	int unique = 0; 
	std :: cout << reused << " " << unique << std :: endl; \\ output1: 42 0
	
	int reused = 0; \\ [B] --> block scope
	std :: cout << reused << " " << unique << std :: endl; \\ output2: 0 0
	
	std : : cout << : : reused << unique << std : : endl; \\ output3: 42 0
	
	return 0;
}
```
output1输出全局变量reused的值；
语句【B】新建了局部变量reused。所以，对于output2，由于新建的局部变量reused正在作用域内，其输出为局部变量reused的值；
output3 使用作用域操作符 : : 来覆盖默认的作用域规则，*因为全局作用域本身没有名字，所以 **当作用域操作符左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量***。结果是，output3输出了全局变量reused的值。
故，若可能用到某全局变量，则不宜再定义一个同名的局部变量。

### 复合类型 ###

**引用 (reference)** 为对象起了另一个名字，即别名。通过(std :: &d) 实现。
```
int ival = 1;
int &refVal = ival;
```

**指针**也可以实现对其他对象的间接访问。使用(std:: \*d)作为声明符定义指针类型，e.g. (std :: int \*ip1)；使用(std :: &d) 来获取对象（std :: d）的地址，并可以将其放置于指针中存储，e.g. (std :: int \*p = &ival )。
指针与引用相比有所不同：
1. 指针本身是一个对象，允许对指针进行赋值和拷贝。
2. 指针可以先后指向几个不同的对象。
3. 指针无需再定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

*要注意，在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以两者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。*

在使用一个指针之前，代码最好检查它是否为空。可以使用(std :: nullptr)来初始化指针，或者将指针赋值为0。

**一个指针指向某对象，同时另一个指针指向另外对象的下一个地址，此时可能出现这两个指针值相同的情况，即指针相等。***

(std :: \*void)可以存放任意对象地址，但是并不了解其中对象类型。

**指针可以指向指针；引用不为对象，故指针无法指向引用，但是指针是对象，故存在对指针的引用。**

### const限定符 ###

const可以用作限定符使变量的值不被改变。其使用形式大致如下：
						(std :: const int bufSize = 512;)

默认状态下，const对象仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。*如果想实现，只在一个文件中定义const，而在其他多个文件中声明并使用它的功能，解决的办法是：*
	对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了：
		                 (std :: extern const int bufSize = fcn();)

在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。当一个常量引用被绑定到另外的一种类型上时，
```
double dval = 3.14 ;
const int &ri = dval;
```
此处(std :: ri)引用了一个int型的数。对(std :: ri)的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让(std :: ri)绑定一个整数，编译器把上述代码变成了如下形式，
```
const int temp = dval; // 由双精度浮点数生成一个临时的整型常量
const int &ri = temp; //让ri绑定这个临时量
```
由于基本大家不会将引用绑定到临时量上，C++语言会把这种行为归为非法。

#### 顶层/底层指针 ####

**顶层指针 -- > 常量指针**

顶层指针必须初始化，而且一旦初始化完成，它的值（即存放于指针中的地址就不能再改变）。此功能由(std :: \*const d)实现，e.g. (std :: int \*const curErr = &errNumb;)。

**底层指针 --> 指向常量的指针**

*底层指针不能用于改变其所指对象的值，可以存放常量对象的地址。* 多数情况下，指针的类型必须与其所指对象的类型一致，但是底层指针为其中一种例外情况，允许底层指针指向一个非常量对象：
```
const double pi = 3.14;
double *ptr = &pi;
const double  *cptr = &pi;
*cptr = 42;
double dval = 3.14;
cptr = &dval;
```

**在执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。** 其中顶层const不受什么影响，但是对底层const却存在不可忽视的限制。当执行对象的拷贝操作时，拷贝对象必须有相同的底层const资格，或者两个对象的数据类型必须能转换。一般来说，非常量可以转换成常量，反之则不行。

C++允许将变量声明为 (std :: constexpr ) 类型以便由编译器来验证变量的值是否是一个常量表达式(const expression)。
\[所谓常量表达式指的是值不会改变且在编译过程就能得到计算结果的表达式\] 
*声明constexpr时用到的类型一般比较简单，一般成为“字面值类型”。* 另外在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。

### 处理类型 ###

**类型别名**：有两种方法可用于定义类型别名。
```
typedef double wages; // wages是double的同义词
using SI = Sales_item; //SI是Sales_item的同义词
```

**auto**：让编译器通过初始值来推算变量的类型，从而去替我们去分析表达式所属的类型。故auto定义的变量必须有初始值：
```
//由val1和val2相加的结果可以推断出item变量
auto item = val1 + val2; //item初始化为val1和val2相加的结果
```
**decltype**：选择并返回操作数的数据类型。在此过程中，*编译器分析表达式并得到它的类型，却不实际计算表达式的值*。
```
decltype (f()) sum = x; // sum 的类型就是函数f的返回类型。
```

**要注意以上类型指示符在复合类型及常量相关结构中的使用**

编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。
1. 编译器以引用类型作为auto的类型。
2. auto一般会忽略掉顶层const，同时底层const则会保留下来：
```
const int ci = i, &cr = ci;
auto b = ci; // b是一个整数 (ci的顶层const特性被忽略掉了)
auto c = cr; // c是一个整数(cr是ci的别名，ci本身是一个顶层const)
auto d = &i; // d是一个整型指针(整数的地址就是指向整数的指针)
auto e = &ci; // e是一个指向整数常量的指针(对常量对象取地址是一种底层const)
```
如果希望推断出的auto类型是一个底层const，***需要明确指出***
```
const auto f = ci; // ci的推演类型是int，f是const int
```
还可以将引用的类型设为auto，此时原来的额初始化规则仍然适用：
```
auto &g = ci; // g是一个整型常量引用，绑定到ci
auto &h = 42; // 错误： 不能为非常量引用绑定字面值
const auto &j = 42; // 正确：可以为常量引用绑定字面值
```
设置一个类型为auto的引用时，初始值种的顶层常量属性仍然保留。注意，当我们给初始值绑定一个引用时，此时的常量就不再是顶层常量了。

decltype处理顶层const和引用的方式与auto有些许不同。
1. 如果decltype使用的表达式是一个变量，那么decltype返回该变量的类型（包括const 和引用在内），如果表达式的内容是解引用操作，则decltype将得到引用类型。e.g. (std :: decltype(\*p))的结果为(std :: int&)而不是(std :: int)：
```
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&,y绑定到x
decltype(cj) z; //错误，z为引用需要初始化
```
2. decltype的结果类型与表达式形式密切相关。*对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有些许不同。* 如果使用的为不加括号的变量，则得到该变量的类型；如果加了一层或者多层括号，编译器会将其按照表达式处理。***注意，decltype((variable))的结果永远是引用，而单层括号结果只有当变量本身为引用时才是引用。***

### 特殊数据结构简述 ###

一个简单的样例：
```
struct Sales_data {
	std :: string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
}; // 记得在类定义后加分号
```

以上类Sales_data只有数据成员，故可以使用类内初始值进行初始化（没有初始值的数据成员将被默认初始化）。

*除了struct，可以使用class定义类*

为了确保在各个文件中的类的定义一致，类通常被定义在头文件中，而且类所在的头文件的名字应与类的名字保持一致。另,程序员有必要在书写头文件时做适当的处理，使其遇到多次包含的情况也能安全和正常地工作。其常用的技术为预处理器(preprocessor)。C++会用到的一项预处理功能为头文件保护符。头文件保护符依赖于预处理变量：(std :: \#define)指令将一个名字设置为预处理变量，(std :: \#ifedf)当且仅当变量已定义时为真；(std :: \#ifnedf)当且仅当变量未定义时为真，一旦结果检验为真，则执行后续操作直到(std :: \#endif)指令为止。
```
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
	std :: string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
#endif
```
*整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般吧处理变量的名字全大写。*



## 各种串串 ##

### 声明 ###

using 声明提供了直接访问命名空间中的名字的功能， (std :: using namespace : : name)。
```
#include <iostream>
{
	int i;
	cin >> i; 
	cout << i; // 错误，没有提前设置对应的using声明，故，需要指明namespace
	std : : cout <<i; // 正确
	return 0;
}
```

*头文件不应该包含using声明。* 原因是，**如果头文件里有某个using声明，那么每个使用了该头文件的文件都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。**

### 可变长的字符序列 string ###

#### 初始化string对象 ####
```
string s1;
string s2(s1);
string s2 = s1;
string s3("value");
string s3 = "value";
string s4(n,'c');
```

#### string 运算 ####
```
os << s;
is >> s;
getline(is, s); // 从is中读取一行赋给s
s.empty();
s.size();
s[n]; // 返回s中n个字符的引用，位置n从0计起
s1 +s2;
s1 == s2;
s1 != s2;
<, <=, >=, > // 利用字符在字典中的顺序进行比较，且对字母的大小写敏感
```

**【Remark】**

1. 在执行读取操作时，string对象会自动忽略开头的空白 （即空格符、换行符、制表符等） 并从第一个真正的字符开始读起，直到遇见下一处空白为止。如果想在输入字符串时保留空白符，则使用( std :: getline())。( std :: getline())在遇到换行符时结束读取操作兵返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。和输入运算符一样，( std :: getline())也会返回它的流参数，由此也可以被用于条件语句检测。

2. 当string输入语句被用作while语句检测流的条件时，如果流有效，也就是说*没有遇到文件结束标记或者非法输入*，那么执行while语句内部的操作。e.g.
```
while ( cin > > word)
	cout < < word < < end; // 逐个输出单词，每个单词后面紧跟一个换行。
```


3. (std :: size())函数返回string :: size_type类型的值。它是一个unsigned值而且足够存放下任何string对象的大小。为了避免混用int和unsigned的潜在问题，尽量不要在同一条表达式中同时使用int和size()函数。

4.  如果两个string对象的长度不同，而且较短的string对象的每个字符都与较长的string对象对应位置上的字符相同，就说较短string对象小于较长的string对象。如果两个string 对象在对某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一队相异字符比较的结果。

5. 标准库允许把字符字面值和字符串字面值转换成string对象。当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string。
#### 关于string中char的一些操作 ####

Keywords: sort; characteristic/property

cctype中规定的一些操作：
```
isalnum (c) // 当c是字母或者数字时为真
isalpha (c) // 当c为字母时为真
iscntrl (c) // 当c是控制字符时为真
isdigit (c) // 当c是数字时为真
isgraph (c) // 当c不是空格但可打印时为真
islower (c) // 当c是小写字母时为真
isprint (c) // 当c是可打印字符时为真(即c是空格或c具有可视形式)
ispunct (c) // 当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)
isspace (c) // 当c是空白时为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种)
isupper (c)
isxdigit (c) // 当c是十六进制数字时为真
tolower (c) // 如果c是大写字母，输出对应的小写字母，否则原样输出
toupper (c)
```

for循环：
(std :: for declaration : expression)
		(std :: statement)

由于string对象表示一个字符序列，故可以被用于for循环语句中expression部分，同样也可以使用for语句将string中的char逐个输出：
```
string str("some string");
for (auto c : str)
	cout << c << endl;
```
如果想改变string中字符的值，需要将循环变量定义成引用类型：
```
string s("Hello World");
for (auto &c : s)
	c = toupper(c);
cout << s << endl;
```

如果只想访问c中的单个字符，可以使用下标或者迭代器。其中下标运算符\[  \] 接收的输入参数是string : : size_type类型的，这个参数代表要访问的字符的位置。返回值是该位置上字符的引用。*string的下标必须 \in \[ 0, s.size() )*。由于C++标准不要求标准库检测下标是否合法。一旦使用了一个超出范围的下标，就会产生不可预知的结果。

### 容器vector ###

C++ 语言既有类模版也有函数模版，其中vector是一个类模版。编译器根据模版创建类或函数的过程称为实例化 ( instantiation)， 当使用模版时，需要指出编译器应把类或函数实例化成什么类型。
```
vector <int> ivec // ivec保存int类型的对象
vector <Sale_item> Sales_vec // 保存Sales_item类型的对象
vector <vector<string>> file // 该向量的元素是vector对象
```

*不存在包含引用的vector*。

#### 初始化vector ####

可以默认初始化vector对象，从而创建一个指定类型的空vector：
```
vector <string> svec; // 默认初始化，svec不含任何元素
```
也可以使用列表初始化vector对象。

还可以用vector对象容纳的元素数量和所有元素的统一初始值来初始化vector对象：
```
vector <int> ivec(10,-1); // 10个int 类型的元素，每个都被初始化为-1
```

通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。如果vector对象的元素是内置类型，比如int，则元素初始值自动设置为0.如果元素是某种类类型，比如string，则类默认初始化。
```
vector <int> ivec(10); // 10个元素，每个都初始化为0
vector <string> svec(10); // 10个元素，每个都是空string对象
```
对这种初始化的方式有两个特殊限制：
1. 有些类要求必须明确的提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。
2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化。
```
vector <int> vi = 10; // 错误：必须使用直接初始化的形式指定向量大小
```
如果初始化时使用打了花括号的形式，但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。
```
vector <string> v5("hi"); // 列表初始化：v5有一个元素
vector <string> v6{"hi"}; //x，不能使用字符串字面值构建vector对象
vector <string> v7{10}; // v7有10个默认初始化的元素
vector <string> v8{10,"hi"}; // v8有10个值为"hi"的元素
```
以上只有v5是列表初始化。*想列表初始化vector对象， 花括号的值必须与元素类型相同。* 确认无法执行列表初始化后，编译器会尝试用默认值初始化vector对象。

#### 对vector进行操作 ####

可以利用push_back向其中添加元素，push_back负责把一个值当成vector对象的尾元素“压到(push)”vector对象的“尾端(back)”。e.g.：
```
vector <int> v2; //空vector对象
for (int i = 0; i != 100; ++i)
	v2.push_back(i); // 依次把整数值放到v2尾端
// 循环结束后, v2有100个元素
```

**其他操作**

v.empty ( ) 如果v不含有人设元素，返回真；否则返回假
v.size ( ) 返回v中元素的个数
v.push_back(t) 向v的尾端添加一个值为t的元素
v\[n\] 返回v中第n个位置上的元素的引用
v1 = v2 
v1 == v2
v1 = {a,b,c,...}
v1 != v2
<, <=, >=, >

### 迭代器 ###

就某个迭代器而言，其对象是容器中的元素或者string对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另一个元素。迭代器有有效和无效之分，有效的迭代器指向某个元素或者容器中尾元素的下一个位置，其他所有情况都属于无效。

不能使用for循环向vector对象添加元素，任何一种可能改变vector对象容量的操作，比如push_back, 都会使该vector对象的迭代器失效。

获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。e.g.
```
auto b = v.begin(), e = v.end(); 
// 由编译器决定b和e的类型,b表示v的第一个元素,e表示v尾元素的下一个位置, b和e的类型相同
```
begin负责返回指向一个元素的迭代器；end负责返回指向容器尾元素的下一个位置的迭代器 ( 常被称为尾后迭代器 )，即该元素是一个容器本不存在的“尾后”元素，可以用来表示我们已经处理完了容器中的所有元素。特殊情况下，如果容器为空，则begin和end返回的是同一个迭代器。*因为end返回的迭代器并不实机指示某个元素，所以不能对其进行递增或者解引用的操作。*
begin和end返回的具体类型是由对象是否是常量决定的，如果是常量，则返回const_iterator，否则为iterator.

```
*iter 返回iter所指元素的引用；
iter -> mem解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem
++iter 使iter指示容器中的下一个元素
--iter 
iter1 == iter2 判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素或者他们是同一个容器的尾后迭代器，则相等；反之，不相等
iter1 != iter2
```

解引用迭代器可获得迭代器所指的对象，如果该对象的类型刚好是类，就有可能进一步访问它的成员。
```
(*it).empty() // 解引用it,然后调用结果对象的empty成员
*it.empty() // 错误：试图访问it的名为empty的成员，但it是个迭代器，没有empty的成员
```

->把解引用和成员访问两个操作符结合在一起，但也就是说, it ->mem和(\*it).mem表达的意思相同。

拥有迭代器的标准库使用iterator和const_iterator来表示迭代器类型。const_iterator类似于常量指针，能读取但是不能修改它所指的元素值。相反，iterator的对象可读可写。

#### 迭代器运算 ####

```
iter + n
iter - n 
iter += n
iter -= n
iter1 - iter2 // 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一个位置。
>,>=,<,<= 迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同个容器中的元素或者尾元素的下一个位置。
```

C++用距离指代右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。因为这个距离可正可负，所以difference_type是带符号类型的。

### 数组 ###

#### 初始化 ####

数组是一种复合类型，其声明形如a\[d\]。默认情况下，数组的元素被默认初始化。定义数组的时候必须定义数组的类型，*不允许用auto关键字由初始值的列表推断类型*。另外和vector一样，数组的元素应该为对象，因此*不存在引用的数组*。

可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反，如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值。不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。

对于字符数组，可以使用字符串字面值对此类数组初始化。当使用这种方式时，**要注意字符串字面值的结尾处还有一个空字符**，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中。
```
char a2[] = {'C','+','+','\0'};
char a3[] = "C++" // 自动添加字符串尾端字符
const a4[6] = "Daniel" // x,没有空间存放空字符
```
为了表达和使用字符串形成了一种约定俗称的字符串写法 —— C风格字符串。按此风格书写的字符串存放在字符数组中并以空字符结束（'\0'）。一般利用指针进行操作。

>任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：
>>1. 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值
>>2. 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

**上述性质反过来就不成立了：如果程序的某处需要一个C风格字符串，无法直接用string对象来替代它。**

对于复杂的数组声明，最好是从数组的名字开始按照由内向外序阅读。
```
int (*Parray)[10] = &arr 
// *Parray定义Parray为一个指针
// Parray指向大小为10的数组
// 数组类型为10
```

#### 访问数组元素 ####

可以通过数组下标访问数组。在使用时通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计的足够大一边能表示内存中任意对象的大小。

在很多用到数组名字的地方，编译器会自动地将其替换为一个指向数组首元素的指针。当使用数组作为一个auto变量的初始值时，推断得到的类型为指针而非数组。数组也是一种迭代器。对于指向数组尾元素下一个位置的指针来说，其实际等价于尾后指针，可用于提供地址用于初始化。

#### 多维数组 ####

对于多维数组的初始化，允许使用花括号括起来的一组值显式地初始化多维数组。如果仅仅想初始化每一行的第一个元素，可以通过显式地初始化每行首元素实现。
```
int ia[3][4] = {{0},{4},{8}}
```

如果表达式含有的下标运算符数量和数组维度一样多，该表达式的结果是给定类型的元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定所引处的一个内层数组，e.g. (std :: int (&row)\[4\] = ia\[1\] ), 把row绑定到ia的第二个4元素数组上。

当program使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。通过使用auto或者decltype就能尽可能避免在数组前面加上一个指针类型了。
```
for (auto p = ia; p != ia + 3; ++p){
	for (auto q = *p; q != *p + 4; ++q)
		cout << *q << ' ';
	cout << endl;
}
```
使用begin和end函数也可以实现同样的功能。

另，在C++新标准中，可以使用类型别名的声明对多维数组的指针进行简化。

# 表达式 #

当一个对象被用作右值时，用的对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。e.g.
```
int i = 0;
cout << i << " " << ++i << endl; //未定义
```
由于此表达式的行为不可预知，因此不论编译器生成什么样的代码程序都是错误的。

### 运算符% ###

俗称“取余”运算符，负责计算两个整数相除所得的余数，参与取余运算的运算对象必须是整数类型；
```
int ival = 42;
double dval = 3.14;
ival % 12;
ival % dval // X
```
如果m%n不等于0，则它的符号和m相同。除了-m导致溢出的问题，其他时候(-m)/n
和m/(-n)都等于-(m/n), m%(-n)等于m%n，(-m)/n等于-(m/n)。

### 关系运算符 ###

关系运算符比较运算对象的大小并返回布尔值。要注意多个关系运算符连在一起时可能产生非预期的作用, e.g. (std :: if(i<j<k))。这里k比较的对象是第一次比较得到的那个或真或假的结果！

### 递增递减运算符 ###

递增和递减运算符有两种形式：前置版本和后置版本。前置版本会先将运算对象加1(减1)，然后将改变后的对象作为求值结果。后置版本也会讲运算对象加1(减1)， 但是求值结果是运算对象改变之前那个值的版本：
```
int i = 0, j;
j = ++i ; // j = 1, i = 1; 
j = i++ ; // j = 1, i = 2;

```
这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置对象将对象原始值的副本作为右值返回。后置运算符的优先级高于解引用运算符。

### 成员访问运算符 ###

点运算符和箭头运算符都可用于访问成员，其中，点运算符获取类型对象的一个成员； 箭头运算符和地运算符有关，表达式(std :: ptr - > mem)等价于( std :: (\*ptr).mem)。

因为解引用运算符的优先级地狱点运算符，所以执行解引用运算的子表达式两端必须加上括号。如果没加括号，代码的含义就大不相同了。

### 条件运算符 ###

条件运算符(? :)允许我们把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：(std :: cond ? expr1 : expr2)
允许在条件运算符的内部嵌套留外一个条件运算符。也就是说，条件表达式可以作为另外一个条件运算符的cond或expr。e.g.
(std :: finalgrade = (grade > 90) ? "high pass" : (grade <60) ? "fail" : "pass";)
条件运算符满足右结合律，意味着运算对象（一般）按照从右向左的顺序组合。因此在上面的代码中，靠右边的条件运算（比较成绩是否小于60）构成了靠左边的条件运算的：分支。
条件运算符的优先级坟场低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要它两端加上括号。

### 位运算符 ###

位运算符作用域整数类型的运算对象，并把运算对象堪称是二进制位的集合。位运算符提供检查和设置二进制位的功能。

<<和>>的内置含义是对其运算对象执行寄予二进制位的移动需求。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数。然后将经过移动的左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。二进制位或者向左移或者右移，移出边界之外的位就被舍弃掉了。
<<在右侧插入值为0的二进制位。>>的行为依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或者值为0的二进制位，如何选择要视具体环境而定。

位求反运算符（~）将运算对象逐位求反后生成一个新值，将1置为0、将0置为1；

### sizeof运算符 ###

返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型。运算符的运算对象有两种形式：
```
sizeof(type)
sizeof expr
```
sizeof运算符的结果部分地依赖于其作用的类型：
对char或者类型为char 的表达式执行sizeof运算，结果为1。
对引用类型执行sizeof运算得到被引用对象所占空间的大小。
对指针执行sizeof运算得到指针本身所占空间的大小。
对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。
对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意sizeof运算不会把数组转换成指针来处理。
对string对象或者vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。
因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数。

### 逗号运算符, ###

逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。

### 类型转换 ###

如果两种类型可以相互转化，那么这两种类型相互关联。

在以下情况下，编译器会自动地转换运算对象的类型（隐式转换）：
在大多数表达式中，比int类型小的整型首先提升为较大的整数类型。
在条件中，非布尔值会转换成布尔类型；
初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型；
如果算数运算或者关系运算的运算对象有多重类型，需要转换成同一种类型；

算数类型转换的含义是把一种算数类型转换成另外一种算数类型。算数转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。
整型提升：把小整数类型转换成较大的整数类型。

如果某个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型，但如果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于极其中各个整数类型的相对大小了。
1. 首先执行整型提升。如果结果的类型匹配，无需进行进一步的转换。
2. 如果运算对象是无符号类型、另外一个运算对象时代符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。
3. 带符号类型大鱼无符号类型，此时转换的结果依赖于极其。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的额运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。

#### 强制类型 ####

一个命名的强制类型转换具有如下形式：
(std :: cast-name < type > (expression));
其中type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。(std :: cast-name) 是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种

*强制类型转换干扰了正常的类型检查，因此我们强烈建议程序员避免使用强制类型转换。这个建议对于reinterpret_cast尤其适用，因为此类类型转换总是充满风险。*

# 语句 #

## 简单语句 ##

如果在程序的某个地方，语法上需要一条语句，但是逻辑上不需要，此时应该使用空语句。e.g.:
```
while (cin >>s && s != sought)
; // 空语句
```
使用空语句时应该加上注释，从而令阅读这段代码的人知道该语句是有意义的。
另，要注意**多余的空语句可能有害**。

复合语句是指用花括号括起来的语句和声明的序列，复合语句也被称作块。一个块为一个作用域。在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。通常，名字在有限的区域内可见，该区域从名字定义处开始，到名字所在的（最内层）块的结尾为止。块不以分号结尾。

如果程序在某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句（块）。

## 结构语句 ##

条件语句 if/switch

迭代语句 while/for/do while
	范围for --> 遍历容器或者其他序列的所有元素
```
vector <int> v = {0,1,2,3};
for (auto &r : v) // 使用r引用范围变量v，从而可以对元素执行写操作
	r *= 2; // v中每个元素的值翻倍
```

*不能使用范围for语句增加vector对象的元素。在范围for语句中预存了end()的值。一旦在序列中添加（删除）元素，end( )的值可能无效化。*

## 跳转语句 ##

跳转语句用于中断当前的执行过程。

**【4种跳转语句】**
break, continue, goto, return.
**break:** 用于终止离它最近的while、do while、for、switch语句，并从这些语句之后的第一条语句开始继续执行。
**continue：** 终止最近的循环中的当前迭代，并立即开始下一次迭代。*continue* 语句中断当前的迭代，但是仍然继续执行循环。对于while或者do while语句来说，继续判断条件的值；对于传统的for循环来说，继续执行for语句头的expression；对于范围for语句来说，则是用序列中的下一个元素初始化循环控制变量。
**goto:** 从goto语句无条件跳转到同一函数内的另一条语句。其语法形式是：(std :: goto label)。其中，label是用于标识一条语句的标示符。带标签语句是一种特殊的语句，在它之前有一个标示符以及一个冒号：
```
end : return
```
标签标示符独立于变量或其他标示符的名字，因此，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。goto语句和控制权转向的那条带标签的语句必须位于同一个函数之内。

注意 goto 语句不能将程序的控制权从变量的作用域之外转椅到作用域之内。且最好不要在程序中使用goto语句。

## 异常及异常处理 ##

当程序某部分检测到一个它无法处理的问题时，需要用到异常处理。此时，检测出问题的部分应该发出某种信号以表明程序遇到了故障无法继续下去了，而且信号灯额发出方无需知道故障将在何处得到解决。一旦发出异常信号，检测出问题的部分也就完成了任务。

如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。如果程序的问题时输入无效，则异常处理部分可能会要求用户重新输入正确的数据；如果丢失了数据库连接，会发出报警信息。

异常处理机制为程序中异常检测和异常处理两部分。

常用的表达式：
1. throw表达式： 异常检测部分使用throw表达式来表示它遇到了无法处理的问题, denoted as throw 引发一个异常。
   throw表达式包含关键字throw和紧随其后的另一个表达式。其中表达式类型就是抛出的异常类型。e.g.:
```
	if(item1.isbn() != item2.isbn())
		throw runtime_error("Data must refer to same ISBN"); 
		// runtime_error为定义在标准库中的一种异常
```
2. try 语句块： 异常处理部分使用try语句块处理异常。try语句块以关键词try开头，并以一个或者多个catch子句结束。try语句块中代码抛出的异常通常会被某个catch子句处理。故称catch语句为异常处理代码。
 通用语法为：
 ```
 try{
 program-statements
 }catch(exception-declaration){
 handler-statements
 }catch(exception-declaration){
 handler-statements
 }// ...
```  
catch子句包括三个部分：关键字，括号内一个（可能未命名的）对象的声明（称作异常声明）以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。
```
while (cin >> item1 >> item2){
	try{
		//执行添加两个Sales_item对象的代码
		//如果添加失败，代码抛出一个runtime_error异常
	}catch(runtime_error err){
	//提醒用户两个ISBN必须一致，询问是否重新输入
	cout << err.what() << "\nTry Again? Enter y or n" << endl;
	char c;
	cin >> c;
	if (!cin || c == 'n')
		break;
	}
}
```
*一个try语句块可能调用了包含另一个try语句块函数。* 寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新函数也将被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直接找到适当类型的catch子句为止。
如果最终还是没能找到任何匹配的catch子句，程序赚到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序异常退出。
***那些在异常发生期间正确执行了“清理”工作的程序被称作异常安全代码。***

3. 异常类：用于在throw表达式和catch子句之间传递异常的具体信息。
exception头文件定义了最通用的异常类；
stdexcept头文件定义了几种常用的异常类；
new头文件定义了bad_alloc异常类型；
type_info头文件定义了bad_cast异常类型。
标准库异常类之定义了几种运算，包括穿件或者拷贝异常类型的对象，以及为异常类型的对象赋值。我们只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。
其他异常类型的行为则恰好相反：应该使用stringstring对象或者C风格字符串初始化这些类型的对象，但是不逊于使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。
异常类型之定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符转的const char*。该字符串的目的是提供关于异常的一些文本信息。
what函数返回的C风格字符串的内容与异常对象的类型有关。如果异常类型有一个字符串初始值，则what返回该字符串。对于其他无初始值的异常类型来说，what返回的内容由编译器决定。