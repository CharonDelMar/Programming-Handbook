## Introduction ##
C++语言可以看作是三部分构成：低级语言、现代高级语言（允许我们定义自己的类型以及组织大规模程序和系统）、标准库（利用高级特性来提供有用的数据结构和算法）。

一个或多个函数 , 其中一个必须命名为 *main.* *main* 的返回值类型必须为 *int*, 一般被用于指示程序运行状态，返回值0代表成功，非0通常用于指示错误类型。

函数定义包含四个部分：return type, function name, parameter list & function body.

运行VS编译器命令：
系统提示符> c1 /编译器选项 源文件名
e.g. (std::C:\\Users\\me\\Programs>c1 /EHsc prog1.cpp)

C++是一种静态类型语言，其含义是*在编译阶段检查类型*。

通常情况下，C++的缩进格式不会影响程序的语义。

C++ 中，一个表达式产生一个运算结果，它由一个或多个运算对象和（通常情况下）一个运算符组成。

C++利用一个标准库来提供io机制。

**iostream library**

One *istream* object：cin (pron: see-in) 标准输入语法
Three *ostream* object：cout (pron: see-out) 标准输出语法、cerr 输出警告和错误消息、clog 输出程序运行时的一般信息

*IO操作一般只作用于当前运行窗口*

\>> 输入运算符 \<< 输出运算符

标准库定义的所有名字都在命名空间std中。*命名空间你可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突*，:: 为作用运算符来指名使用命令所在的命名空间。e.g. cout和endl定义在名为std的命名空间，所以调用时一般使用std : : cout和std : : endl。
>endl为一个被称为manipulator的特殊值，写入endl的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。**缓冲刷新操作可以保证到目前为止程序所产生的扫有输出都真正写入输出流中，而不是进停留在内存中等待写入流。**
  >>*程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。*


Comments: 单行注释 //    多行注释  /* \*/

循环结构：while for
使用一个*istream*对象作为条件时，其效果是**检测流的状态**。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符*end-of-file*，或者遇到一个无效输入时，*istream*对象的状态会变为无效。处于无效状态的*istream*对象会使条件变为假。
其应用形式类似于：(std:: while ( std : : cin >> value ))
>对于Windows系统，从键盘输入文件结束符的方式为 (std:: Ctrl +Z )
>对于macOX系统，从键盘输入文件结束符的方式为 (std:: Ctrl +D)

### Datatype (More Details in **Data Structure** ) ###

*当明确知晓数值不可能为负时，选用无符号类型*
*执行浮点数运算选用double*
*当一个算数表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。从无符号数中减去一个值时，我们要保证结果不可能为负。*

关于一些强行类型转换：
>非布尔类型的算数值 >> bool：初始值为0则结果为false，否则结果为true。
>bool >> 非布尔类型：初始值为false则结果为0, 初始值为true则结果为1。
>浮点数 >> int：结果仅保留小数点以前的部分。
>int >> 浮点数：小数部分记为0。若int所占空间超过浮点数则可能损失精度。
>unsigned >> 超出其表示范围的值，结果是初始值对无符号类型表示数值总数**取模**后的余数
>signed >> 超出其表示范围的值，结果未知，程序可能正常工作/崩溃/生成垃圾数据。

如果两个字符串字面值位置紧邻且仅有空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式，e.g.：
(std:: std : : cout << "a really, really long string literal")
                 (std:: "that spans two lines" << std : : endl; )

C++可以通过给字面值字符添加前后缀指定字面值类型；

转义字符（详见C++ documentation --> escape sequence）

## Variables ###

*初始化不是赋值！！！初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，然后用一个新值来代替。*

#### Initialisation ####

C++定义了多种初始化形式。

#### 列表初始化 ####

使用花括号初始化变量，e.g. (std:: int units_sold{0};)

 *当用于内置类型的变量时，如果我们使用列表初始化且存在丢失信息的风险，则编译器将报错。*
```
long double ld = 3.1415936;
int a{ld}, b = {ld};
int c(ld), d = ld;
```

#### 数组初始化 ####

允许使用数组来初始化vector对象。要实现这一目的，只需要指明要拷贝区域的首元素地址和尾后地址就可以了：
```
int int_arr[] = {0,1,2,3,4,5};
vector<int> ivec(begin(int_arr),end(int_arr));
```
#### 默认初始化 ####

如果定义变量时没有指定初始值，则变量被默认初始化，此时变量被赋予了default value。default value到底是什么由变量类型决定并受到定义变量的位置的影响。
如果是内置类型变量未被初始化，它的值一般由定义的位置决定。但是 *定义在函数体内部的内置类型变量将不被初始化。如果试图拷贝或以其他形式访问此类型将引发错误。*

每个类各自决定其初始化对象的方式，而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么 （*类的对象如果没有显式初始化，则其类型由类本身决定。*）。
绝大多数类都支持无须显式初始化而定义对象。
e.g.: (std:: std : : string empty // empty 非显式地初始化为一个空串。)
若不支持此功能的类的对象没有进行显式初始化，则程序会报错。

#### Declaration  & Definition ####

声明规定了变量的类型和名字；
定义规定了变量的类型和名字，申请存储空间，还可能为变量赋一个初值。

*如果想声明一个变量而不是定义它，需要使用 extern，且 **不要显式地初始化变量！！！*** 
```
extern int i; \\ Declaration
int j; \\ Definition
extern int k = 1; \\ Definition
```

*变量能且只能被定义一次，但可以被多次声明。* 如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现且只能出现在同一个文件中，而其他使用该变量的文件必须对其进行声明，**却决不能重复定义** 。

多数情况下可以等价使用不同的初始化方式，几种例外情况是：
1. 使用拷贝初始化时（即使用=时），只能提供一个初始值；
2. 如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化；
3. 如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里：
```
vector <string> v1{"a", "an", "the"}; // √
vector <string> v2("a", "an", "the"); // x
```
#### 作用域 Scope ####

```
int reused = 42; \\ [A] --> global scope
int main(){

	int unique = 0; 
	std :: cout << reused << " " << unique << std :: endl; \\ output1: 42 0
	
	int reused = 0; \\ [B] --> block scope
	std :: cout << reused << " " << unique << std :: endl; \\ output2: 0 0
	
	std : : cout << : : reused << unique << std : : endl; \\ output3: 42 0
	
	return 0;
}
```
output1输出全局变量reused的值；
语句【B】新建了局部变量reused。所以，对于output2，由于新建的局部变量reused正在作用域内，其输出为局部变量reused的值；
output3 使用作用域操作符 : : 来覆盖默认的作用域规则，*因为全局作用域本身没有名字，所以 **当作用域操作符左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量***。结果是，output3输出了全局变量reused的值。
故，若可能用到某全局变量，则不宜再定义一个同名的局部变量。

### 复合类型 ###

**引用 (reference)** 为对象起了另一个名字，即别名。通过(std :: &d) 实现。
```
int ival = 1;
int &refVal = ival;
```

**指针**也可以实现对其他对象的间接访问。使用(std:: \*d)作为声明符定义指针类型，e.g. (std :: int \*ip1)；使用(std :: &d) 来获取对象（std :: d）的地址，并可以将其放置于指针中存储，e.g. (std :: int \*p = &ival )。
指针与引用相比有所不同：
1. 指针本身是一个对象，允许对指针进行赋值和拷贝。
2. 指针可以先后指向几个不同的对象。
3. 指针无需再定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

*要注意，在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以两者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。*

在使用一个指针之前，代码最好检查它是否为空。可以使用(std :: nullptr)来初始化指针，或者将指针赋值为0。

**一个指针指向某对象，同时另一个指针指向另外对象的下一个地址，此时可能出现这两个指针值相同的情况，即指针相等。***

(std :: \*void)可以存放任意对象地址，但是并不了解其中对象类型。

**指针可以指向指针；引用不为对象，故指针无法指向引用，但是指针是对象，故存在对指针的引用。**

### const限定符 ###

const可以用作限定符使变量的值不被改变。其使用形式大致如下：
						(std :: const int bufSize = 512;)

默认状态下，const对象仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。*如果想实现，只在一个文件中定义const，而在其他多个文件中声明并使用它的功能，解决的办法是：*
	对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了：
		                 (std :: extern const int bufSize = fcn();)

在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。当一个常量引用被绑定到另外的一种类型上时，
```
double dval = 3.14 ;
const int &ri = dval;
```
此处(std :: ri)引用了一个int型的数。对(std :: ri)的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让(std :: ri)绑定一个整数，编译器把上述代码变成了如下形式，
```
const int temp = dval; // 由双精度浮点数生成一个临时的整型常量
const int &ri = temp; //让ri绑定这个临时量
```
由于基本大家不会将引用绑定到临时量上，C++语言会把这种行为归为非法。

#### 顶层/底层指针 ####

**顶层指针 -- > 常量指针**

顶层指针必须初始化，而且一旦初始化完成，它的值（即存放于指针中的地址就不能再改变）。此功能由(std :: \*const d)实现，e.g. (std :: int \*const curErr = &errNumb;)。

**底层指针 --> 指向常量的指针**

*底层指针不能用于改变其所指对象的值，可以存放常量对象的地址。* 多数情况下，指针的类型必须与其所指对象的类型一致，但是底层指针为其中一种例外情况，允许底层指针指向一个非常量对象：
```
const double pi = 3.14;
double *ptr = &pi;
const double  *cptr = &pi;
*cptr = 42;
double dval = 3.14;
cptr = &dval;
```

**在执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。** 其中顶层const不受什么影响，但是对底层const却存在不可忽视的限制。当执行对象的拷贝操作时，拷贝对象必须有相同的底层const资格，或者两个对象的数据类型必须能转换。一般来说，非常量可以转换成常量，反之则不行。

C++允许将变量声明为 (std :: constexpr ) 类型以便由编译器来验证变量的值是否是一个常量表达式(const expression)。
\[所谓常量表达式指的是值不会改变且在编译过程就能得到计算结果的表达式\] 
*声明constexpr时用到的类型一般比较简单，一般成为“字面值类型”。* 另外在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。

### 处理类型 ###

**类型别名**：有两种方法可用于定义类型别名。
```
typedef double wages; // wages是double的同义词
using SI = Sales_item; //SI是Sales_item的同义词
```

**auto**：让编译器通过初始值来推算变量的类型，从而去替我们去分析表达式所属的类型。故auto定义的变量必须有初始值：
```
//由val1和val2相加的结果可以推断出item变量
auto item = val1 + val2; //item初始化为val1和val2相加的结果
```
**decltype**：选择并返回操作数的数据类型。在此过程中，*编译器分析表达式并得到它的类型，却不实际计算表达式的值*。
```
decltype (f()) sum = x; // sum 的类型就是函数f的返回类型。
```

**要注意以上类型指示符在复合类型及常量相关结构中的使用**

编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。
1. 编译器以引用类型作为auto的类型。
2. auto一般会忽略掉顶层const，同时底层const则会保留下来：
```
const int ci = i, &cr = ci;
auto b = ci; // b是一个整数 (ci的顶层const特性被忽略掉了)
auto c = cr; // c是一个整数(cr是ci的别名，ci本身是一个顶层const)
auto d = &i; // d是一个整型指针(整数的地址就是指向整数的指针)
auto e = &ci; // e是一个指向整数常量的指针(对常量对象取地址是一种底层const)
```
如果希望推断出的auto类型是一个底层const，***需要明确指出***
```
const auto f = ci; // ci的推演类型是int，f是const int
```
还可以将引用的类型设为auto，此时原来的额初始化规则仍然适用：
```
auto &g = ci; // g是一个整型常量引用，绑定到ci
auto &h = 42; // 错误： 不能为非常量引用绑定字面值
const auto &j = 42; // 正确：可以为常量引用绑定字面值
```
设置一个类型为auto的引用时，初始值种的顶层常量属性仍然保留。注意，当我们给初始值绑定一个引用时，此时的常量就不再是顶层常量了。

decltype处理顶层const和引用的方式与auto有些许不同。
1. 如果decltype使用的表达式是一个变量，那么decltype返回该变量的类型（包括const 和引用在内），如果表达式的内容是解引用操作，则decltype将得到引用类型。e.g. (std :: decltype(\*p))的结果为(std :: int&)而不是(std :: int)：
```
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&,y绑定到x
decltype(cj) z; //错误，z为引用需要初始化
```
2. decltype的结果类型与表达式形式密切相关。*对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有些许不同。* 如果使用的为不加括号的变量，则得到该变量的类型；如果加了一层或者多层括号，编译器会将其按照表达式处理。***注意，decltype((variable))的结果永远是引用，而单层括号结果只有当变量本身为引用时才是引用。***

### 特殊数据结构简述 ###

一个简单的样例：
```
struct Sales_data {
	std :: string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
}; // 记得在类定义后加分号
```

以上类Sales_data只有数据成员，故可以使用类内初始值进行初始化（没有初始值的数据成员将被默认初始化）。

*除了struct，可以使用class定义类*

为了确保在各个文件中的类的定义一致，类通常被定义在头文件中，而且类所在的头文件的名字应与类的名字保持一致。另,程序员有必要在书写头文件时做适当的处理，使其遇到多次包含的情况也能安全和正常地工作。其常用的技术为预处理器(preprocessor)。C++会用到的一项预处理功能为头文件保护符。头文件保护符依赖于预处理变量：(std :: \#define)指令将一个名字设置为预处理变量，(std :: \#ifedf)当且仅当变量已定义时为真；(std :: \#ifnedf)当且仅当变量未定义时为真，一旦结果检验为真，则执行后续操作直到(std :: \#endif)指令为止。
```
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
	std :: string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
#endif
```
*整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般吧处理变量的名字全大写。*



## 各种串串 ##

### 声明 ###

using 声明提供了直接访问命名空间中的名字的功能， (std :: using namespace : : name)。
```
#include <iostream>
{
	int i;
	cin >> i; 
	cout << i; // 错误，没有提前设置对应的using声明，故，需要指明namespace
	std : : cout <<i; // 正确
	return 0;
}
```

*头文件不应该包含using声明。* 原因是，**如果头文件里有某个using声明，那么每个使用了该头文件的文件都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。**

### 可变长的字符序列 string ###

#### 初始化string对象 ####
```
string s1;
string s2(s1);
string s2 = s1;
string s3("value");
string s3 = "value";
string s4(n,'c');
```

#### string 运算 ####
```
os << s;
is >> s;
getline(is, s); // 从is中读取一行赋给s
s.empty();
s.size();
s[n]; // 返回s中n个字符的引用，位置n从0计起
s1 +s2;
s1 == s2;
s1 != s2;
<, <=, >=, > // 利用字符在字典中的顺序进行比较，且对字母的大小写敏感
```

**【Remark】**

1. 在执行读取操作时，string对象会自动忽略开头的空白 （即空格符、换行符、制表符等） 并从第一个真正的字符开始读起，直到遇见下一处空白为止。如果想在输入字符串时保留空白符，则使用( std :: getline())。( std :: getline())在遇到换行符时结束读取操作兵返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空string。和输入运算符一样，( std :: getline())也会返回它的流参数，由此也可以被用于条件语句检测。

2. 当string输入语句被用作while语句检测流的条件时，如果流有效，也就是说*没有遇到文件结束标记或者非法输入*，那么执行while语句内部的操作。e.g.
```
while ( cin > > word)
	cout < < word < < end; // 逐个输出单词，每个单词后面紧跟一个换行。
```


3. (std :: size())函数返回string :: size_type类型的值。它是一个unsigned值而且足够存放下任何string对象的大小。为了避免混用int和unsigned的潜在问题，尽量不要在同一条表达式中同时使用int和size()函数。

4.  如果两个string对象的长度不同，而且较短的string对象的每个字符都与较长的string对象对应位置上的字符相同，就说较短string对象小于较长的string对象。如果两个string 对象在对某些对应的位置上不一致，则string对象比较的结果其实是string对象中第一队相异字符比较的结果。

5. 标准库允许把字符字面值和字符串字面值转换成string对象。当把string对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是string。
#### 关于string中char的一些操作 ####

Keywords: sort; characteristic/property

cctype中规定的一些操作：
```
isalnum (c) // 当c是字母或者数字时为真
isalpha (c) // 当c为字母时为真
iscntrl (c) // 当c是控制字符时为真
isdigit (c) // 当c是数字时为真
isgraph (c) // 当c不是空格但可打印时为真
islower (c) // 当c是小写字母时为真
isprint (c) // 当c是可打印字符时为真(即c是空格或c具有可视形式)
ispunct (c) // 当c是标点符号时为真(即c不是控制字符、数字、字母、可打印空白中的一种)
isspace (c) // 当c是空白时为真(即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种)
isupper (c)
isxdigit (c) // 当c是十六进制数字时为真
tolower (c) // 如果c是大写字母，输出对应的小写字母，否则原样输出
toupper (c)
```

for循环：
(std :: for declaration : expression)
		(std :: statement)

由于string对象表示一个字符序列，故可以被用于for循环语句中expression部分，同样也可以使用for语句将string中的char逐个输出：
```
string str("some string");
for (auto c : str)
	cout << c << endl;
```
如果想改变string中字符的值，需要将循环变量定义成引用类型：
```
string s("Hello World");
for (auto &c : s)
	c = toupper(c);
cout << s << endl;
```

如果只想访问c中的单个字符，可以使用下标或者迭代器。其中下标运算符\[  \] 接收的输入参数是string : : size_type类型的，这个参数代表要访问的字符的位置。返回值是该位置上字符的引用。*string的下标必须 \in \[ 0, s.size() )*。由于C++标准不要求标准库检测下标是否合法。一旦使用了一个超出范围的下标，就会产生不可预知的结果。

### 容器vector ###

C++ 语言既有类模版也有函数模版，其中vector是一个类模版。编译器根据模版创建类或函数的过程称为实例化 ( instantiation)， 当使用模版时，需要指出编译器应把类或函数实例化成什么类型。
```
vector <int> ivec // ivec保存int类型的对象
vector <Sale_item> Sales_vec // 保存Sales_item类型的对象
vector <vector<string>> file // 该向量的元素是vector对象
```

*不存在包含引用的vector*。

#### 初始化vector ####

可以默认初始化vector对象，从而创建一个指定类型的空vector：
```
vector <string> svec; // 默认初始化，svec不含任何元素
```
也可以使用列表初始化vector对象。

还可以用vector对象容纳的元素数量和所有元素的统一初始值来初始化vector对象：
```
vector <int> ivec(10,-1); // 10个int 类型的元素，每个都被初始化为-1
```

通常情况下，可以只提供vector对象容纳的元素数量而略去初始值。此时库会创建一个值初始化的元素初值，并把它赋给容器中的所有元素。这个初值由vector对象中元素的类型决定。如果vector对象的元素是内置类型，比如int，则元素初始值自动设置为0.如果元素是某种类类型，比如string，则类默认初始化。
```
vector <int> ivec(10); // 10个元素，每个都初始化为0
vector <string> svec(10); // 10个元素，每个都是空string对象
```
对这种初始化的方式有两个特殊限制：
1. 有些类要求必须明确的提供初始值，如果vector对象中元素的类型不支持默认初始化，我们就必须提供初始的元素值。
2. 如果只提供了元素的数量而没有设定初始值，只能使用直接初始化。
```
vector <int> vi = 10; // 错误：必须使用直接初始化的形式指定向量大小
```
如果初始化时使用打了花括号的形式，但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造vector对象了。
```
vector <string> v5("hi"); // 列表初始化：v5有一个元素
vector <string> v6{"hi"}; //x，不能使用字符串字面值构建vector对象
vector <string> v7{10}; // v7有10个默认初始化的元素
vector <string> v8{10,"hi"}; // v8有10个值为"hi"的元素
```
以上只有v5是列表初始化。*想列表初始化vector对象， 花括号的值必须与元素类型相同。* 确认无法执行列表初始化后，编译器会尝试用默认值初始化vector对象。

#### 对vector进行操作 ####

可以利用push_back向其中添加元素，push_back负责把一个值当成vector对象的尾元素“压到(push)”vector对象的“尾端(back)”。e.g.：
```
vector <int> v2; //空vector对象
for (int i = 0; i != 100; ++i)
	v2.push_back(i); // 依次把整数值放到v2尾端
// 循环结束后, v2有100个元素
```

**其他操作**

v.empty ( ) 如果v不含有人设元素，返回真；否则返回假
v.size ( ) 返回v中元素的个数
v.push_back(t) 向v的尾端添加一个值为t的元素
v\[n\] 返回v中第n个位置上的元素的引用
v1 = v2 
v1 == v2
v1 = {a,b,c,...}
v1 != v2
<, <=, >=, >

### 迭代器 ###

就某个迭代器而言，其对象是容器中的元素或者string对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另一个元素。迭代器有有效和无效之分，有效的迭代器指向某个元素或者容器中尾元素的下一个位置，其他所有情况都属于无效。

不能使用for循环向vector对象添加元素，任何一种可能改变vector对象容量的操作，比如push_back, 都会使该vector对象的迭代器失效。

获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。e.g.
```
auto b = v.begin(), e = v.end(); 
// 由编译器决定b和e的类型,b表示v的第一个元素,e表示v尾元素的下一个位置, b和e的类型相同
```
begin负责返回指向一个元素的迭代器；end负责返回指向容器尾元素的下一个位置的迭代器 ( 常被称为尾后迭代器 )，即该元素是一个容器本不存在的“尾后”元素，可以用来表示我们已经处理完了容器中的所有元素。特殊情况下，如果容器为空，则begin和end返回的是同一个迭代器。*因为end返回的迭代器并不实机指示某个元素，所以不能对其进行递增或者解引用的操作。*
begin和end返回的具体类型是由对象是否是常量决定的，如果是常量，则返回const_iterator，否则为iterator.

```
*iter 返回iter所指元素的引用；
iter -> mem解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem
++iter 使iter指示容器中的下一个元素
--iter 
iter1 == iter2 判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素或者他们是同一个容器的尾后迭代器，则相等；反之，不相等
iter1 != iter2
```

解引用迭代器可获得迭代器所指的对象，如果该对象的类型刚好是类，就有可能进一步访问它的成员。
```
(*it).empty() // 解引用it,然后调用结果对象的empty成员
*it.empty() // 错误：试图访问it的名为empty的成员，但it是个迭代器，没有empty的成员
```

->把解引用和成员访问两个操作符结合在一起，但也就是说, it ->mem和(\*it).mem表达的意思相同。

拥有迭代器的标准库使用iterator和const_iterator来表示迭代器类型。const_iterator类似于常量指针，能读取但是不能修改它所指的元素值。相反，iterator的对象可读可写。

#### 迭代器运算 ####

```
iter + n
iter - n 
iter += n
iter -= n
iter1 - iter2 // 两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一个位置。
>,>=,<,<= 迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同个容器中的元素或者尾元素的下一个位置。
```

C++用距离指代右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为difference_type的带符号整型数。因为这个距离可正可负，所以difference_type是带符号类型的。

### 数组 ###

#### 初始化 ####

数组是一种复合类型，其声明形如a\[d\]。默认情况下，数组的元素被默认初始化。定义数组的时候必须定义数组的类型，*不允许用auto关键字由初始值的列表推断类型*。另外和vector一样，数组的元素应该为对象，因此*不存在引用的数组*。

可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来；相反，如果指明了维度，那么初始值的总数量不应该超出指定的大小。如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值。不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值。

对于字符数组，可以使用字符串字面值对此类数组初始化。当使用这种方式时，**要注意字符串字面值的结尾处还有一个空字符**，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中。
```
char a2[] = {'C','+','+','\0'};
char a3[] = "C++" // 自动添加字符串尾端字符
const a4[6] = "Daniel" // x,没有空间存放空字符
```
为了表达和使用字符串形成了一种约定俗称的字符串写法 —— C风格字符串。按此风格书写的字符串存放在字符数组中并以空字符结束（'\0'）。一般利用指针进行操作。

>任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代：
>>1. 允许使用以空字符结束的字符数组来初始化string对象或者为string对象赋值
>>2. 在string对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（不能两个运算对象都是）；在string对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。

**上述性质反过来就不成立了：如果程序的某处需要一个C风格字符串，无法直接用string对象来替代它。**

对于复杂的数组声明，最好是从数组的名字开始按照由内向外序阅读。
```
int (*Parray)[10] = &arr 
// *Parray定义Parray为一个指针
// Parray指向大小为10的数组
// 数组类型为10
```

#### 访问数组元素 ####

可以通过数组下标访问数组。在使用时通常将其定义为size_t类型。size_t是一种机器相关的无符号类型，它被设计的足够大一边能表示内存中任意对象的大小。

在很多用到数组名字的地方，编译器会自动地将其替换为一个指向数组首元素的指针。当使用数组作为一个auto变量的初始值时，推断得到的类型为指针而非数组。数组也是一种迭代器。对于指向数组尾元素下一个位置的指针来说，其实际等价于尾后指针，可用于提供地址用于初始化。

#### 多维数组 ####

对于多维数组的初始化，允许使用花括号括起来的一组值显式地初始化多维数组。如果仅仅想初始化每一行的第一个元素，可以通过显式地初始化每行首元素实现。
```
int ia[3][4] = {{0},{4},{8}}
```

如果表达式含有的下标运算符数量和数组维度一样多，该表达式的结果是给定类型的元素；反之，如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定所引处的一个内层数组，e.g. (std :: int (&row)\[4\] = ia\[1\] ), 把row绑定到ia的第二个4元素数组上。

当program使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。通过使用auto或者decltype就能尽可能避免在数组前面加上一个指针类型了。
```
for (auto p = ia; p != ia + 3; ++p){
	for (auto q = *p; q != *p + 4; ++q)
		cout << *q << ' ';
	cout << endl;
}
```
使用begin和end函数也可以实现同样的功能。

另，在C++新标准中，可以使用类型别名的声明对多维数组的指针进行简化。

# 表达式 #

当一个对象被用作右值时，用的对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）。

对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。e.g.
```
int i = 0;
cout << i << " " << ++i << endl; //未定义
```
由于此表达式的行为不可预知，因此不论编译器生成什么样的代码程序都是错误的。

### 运算符% ###

俗称“取余”运算符，负责计算两个整数相除所得的余数，参与取余运算的运算对象必须是整数类型；
```
int ival = 42;
double dval = 3.14;
ival % 12;
ival % dval // X
```
如果m%n不等于0，则它的符号和m相同。除了-m导致溢出的问题，其他时候(-m)/n
和m/(-n)都等于-(m/n), m%(-n)等于m%n，(-m)/n等于-(m/n)。

### 关系运算符 ###

关系运算符比较运算对象的大小并返回布尔值。要注意多个关系运算符连在一起时可能产生非预期的作用, e.g. (std :: if(i<j<k))。这里k比较的对象是第一次比较得到的那个或真或假的结果！

### 递增递减运算符 ###

递增和递减运算符有两种形式：前置版本和后置版本。前置版本会先将运算对象加1(减1)，然后将改变后的对象作为求值结果。后置版本也会讲运算对象加1(减1)， 但是求值结果是运算对象改变之前那个值的版本：
```
int i = 0, j;
j = ++i ; // j = 1, i = 1; 
j = i++ ; // j = 1, i = 2;

```
这两种运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置对象将对象原始值的副本作为右值返回。后置运算符的优先级高于解引用运算符。

### 成员访问运算符 ###

点运算符和箭头运算符都可用于访问成员，其中，点运算符获取类型对象的一个成员； 箭头运算符和地运算符有关，表达式(std :: ptr - > mem)等价于( std :: (\*ptr).mem)。

因为解引用运算符的优先级地狱点运算符，所以执行解引用运算的子表达式两端必须加上括号。如果没加括号，代码的含义就大不相同了。

### 条件运算符 ###

条件运算符(? :)允许我们把简单的if-else逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：(std :: cond ? expr1 : expr2)
允许在条件运算符的内部嵌套留外一个条件运算符。也就是说，条件表达式可以作为另外一个条件运算符的cond或expr。e.g.
(std :: finalgrade = (grade > 90) ? "high pass" : (grade <60) ? "fail" : "pass";)
条件运算符满足右结合律，意味着运算对象（一般）按照从右向左的顺序组合。因此在上面的代码中，靠右边的条件运算（比较成绩是否小于60）构成了靠左边的条件运算的：分支。
条件运算符的优先级坟场低，因此当一条长表达式中嵌套了条件运算子表达式时，通常需要它两端加上括号。

### 位运算符 ###

位运算符作用域整数类型的运算对象，并把运算对象堪称是二进制位的集合。位运算符提供检查和设置二进制位的功能。

<<和>>的内置含义是对其运算对象执行寄予二进制位的移动需求。首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数。然后将经过移动的左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。二进制位或者向左移或者右移，移出边界之外的位就被舍弃掉了。
<<在右侧插入值为0的二进制位。>>的行为依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为0的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或者值为0的二进制位，如何选择要视具体环境而定。

位求反运算符（~）将运算对象逐位求反后生成一个新值，将1置为0、将0置为1；

### sizeof运算符 ###

返回一条表达式或一个类型名字所占的字节数。sizeof运算符满足右结合律，其所得的值是一个size_t类型。运算符的运算对象有两种形式：
```
sizeof(type)
sizeof expr
```
sizeof运算符的结果部分地依赖于其作用的类型：
对char或者类型为char 的表达式执行sizeof运算，结果为1。
对引用类型执行sizeof运算得到被引用对象所占空间的大小。
对指针执行sizeof运算得到指针本身所占空间的大小。
对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。
对数组执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将所得结果求和。注意sizeof运算不会把数组转换成指针来处理。
对string对象或者vector对象执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。
因为执行sizeof运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数。

### 逗号运算符, ###

逗号运算符含有两个运算对象，按照从左向右的顺序依次求值。首先对左侧的表达式求值，然后将求值结果丢弃掉。逗号运算符真正的结果是右侧表达式的值。如果右侧运算对象是左值，那么最终的求值结果也是左值。

### 类型转换 ###

如果两种类型可以相互转化，那么这两种类型相互关联。

在以下情况下，编译器会自动地转换运算对象的类型（隐式转换）：
在大多数表达式中，比int类型小的整型首先提升为较大的整数类型。
在条件中，非布尔值会转换成布尔类型；
初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型；
如果算数运算或者关系运算的运算对象有多重类型，需要转换成同一种类型；

算数类型转换的含义是把一种算数类型转换成另外一种算数类型。算数转换的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。
整型提升：把小整数类型转换成较大的整数类型。

如果某个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型，但如果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于极其中各个整数类型的相对大小了。
1. 首先执行整型提升。如果结果的类型匹配，无需进行进一步的转换。
2. 如果运算对象是无符号类型、另外一个运算对象时代符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。
3. 带符号类型大鱼无符号类型，此时转换的结果依赖于极其。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的额运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。

#### 强制类型 ####

一个命名的强制类型转换具有如下形式：
(std :: cast-name < type > (expression));
其中type是转换的目标类型而expression是要转换的值。如果type是引用类型，则结果是左值。(std :: cast-name) 是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种

*强制类型转换干扰了正常的类型检查，因此我们强烈建议程序员避免使用强制类型转换。这个建议对于reinterpret_cast尤其适用，因为此类类型转换总是充满风险。*

# 语句 #

## 简单语句 ##

如果在程序的某个地方，语法上需要一条语句，但是逻辑上不需要，此时应该使用空语句。e.g.:
```
while (cin >>s && s != sought)
; // 空语句
```
使用空语句时应该加上注释，从而令阅读这段代码的人知道该语句是有意义的。
另，要注意**多余的空语句可能有害**。

复合语句是指用花括号括起来的语句和声明的序列，复合语句也被称作块。一个块为一个作用域。在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。通常，名字在有限的区域内可见，该区域从名字定义处开始，到名字所在的（最内层）块的结尾为止。块不以分号结尾。

如果程序在某个地方，语法上需要一条语句，但是逻辑上需要多条语句，则应该使用复合语句（块）。

## 结构语句 ##

条件语句 if/switch

迭代语句 while/for/do while
	范围for --> 遍历容器或者其他序列的所有元素
```
vector <int> v = {0,1,2,3};
for (auto &r : v) // 使用r引用范围变量v，从而可以对元素执行写操作
	r *= 2; // v中每个元素的值翻倍
```

*不能使用范围for语句增加vector对象的元素。在范围for语句中预存了end()的值。一旦在序列中添加（删除）元素，end( )的值可能无效化。*

## 跳转语句 ##

跳转语句用于中断当前的执行过程。

**【4种跳转语句】**
break, continue, goto, return.
**break:** 用于终止离它最近的while、do while、for、switch语句，并从这些语句之后的第一条语句开始继续执行。
**continue：** 终止最近的循环中的当前迭代，并立即开始下一次迭代。*continue* 语句中断当前的迭代，但是仍然继续执行循环。对于while或者do while语句来说，继续判断条件的值；对于传统的for循环来说，继续执行for语句头的expression；对于范围for语句来说，则是用序列中的下一个元素初始化循环控制变量。
**goto:** 从goto语句无条件跳转到同一函数内的另一条语句。其语法形式是：(std :: goto label)。其中，label是用于标识一条语句的标示符。带标签语句是一种特殊的语句，在它之前有一个标示符以及一个冒号：
```
end : return
```
标签标示符独立于变量或其他标示符的名字，因此，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。goto语句和控制权转向的那条带标签的语句必须位于同一个函数之内。

注意 goto 语句不能将程序的控制权从变量的作用域之外转椅到作用域之内。且最好不要在程序中使用goto语句。

## 异常及异常处理 ##

当程序某部分检测到一个它无法处理的问题时，需要用到异常处理。此时，检测出问题的部分应该发出某种信号以表明程序遇到了故障无法继续下去了，而且信号灯额发出方无需知道故障将在何处得到解决。一旦发出异常信号，检测出问题的部分也就完成了任务。

如果程序中含有可能引发异常的代码，那么通常也会有专门的代码处理问题。如果程序的问题时输入无效，则异常处理部分可能会要求用户重新输入正确的数据；如果丢失了数据库连接，会发出报警信息。

异常处理机制为程序中异常检测和异常处理两部分。

常用的表达式：
1. throw表达式： 异常检测部分使用throw表达式来表示它遇到了无法处理的问题, denoted as throw 引发一个异常。
   throw表达式包含关键字throw和紧随其后的另一个表达式。其中表达式类型就是抛出的异常类型。e.g.:
```
	if(item1.isbn() != item2.isbn())
		throw runtime_error("Data must refer to same ISBN"); 
		// runtime_error为定义在标准库中的一种异常
```
2. try 语句块： 异常处理部分使用try语句块处理异常。try语句块以关键词try开头，并以一个或者多个catch子句结束。try语句块中代码抛出的异常通常会被某个catch子句处理。故称catch语句为异常处理代码。
 通用语法为：
 ```
 try{
 program-statements
 }catch(exception-declaration){
 handler-statements
 }catch(exception-declaration){
 handler-statements
 }// ...
```  
catch子句包括三个部分：关键字，括号内一个（可能未命名的）对象的声明（称作异常声明）以及一个块。当选中了某个catch子句处理异常之后，执行与之对应的块。catch一旦完成，程序跳转到try语句块最后一个catch子句之后的那条语句继续执行。
```
while (cin >> item1 >> item2){
	try{
		//执行添加两个Sales_item对象的代码
		//如果添加失败，代码抛出一个runtime_error异常
	}catch(runtime_error err){
	//提醒用户两个ISBN必须一致，询问是否重新输入
	cout << err.what() << "\nTry Again? Enter y or n" << endl;
	char c;
	cin >> c;
	if (!cin || c == 'n')
		break;
	}
}
```
*一个try语句块可能调用了包含另一个try语句块函数。* 寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的catch子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的catch子句，这个新函数也将被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直接找到适当类型的catch子句为止。
如果最终还是没能找到任何匹配的catch子句，程序赚到名为terminate的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序异常退出。
***那些在异常发生期间正确执行了“清理”工作的程序被称作异常安全代码。***

3. 异常类：用于在throw表达式和catch子句之间传递异常的具体信息。
exception头文件定义了最通用的异常类；
stdexcept头文件定义了几种常用的异常类；
new头文件定义了bad_alloc异常类型；
type_info头文件定义了bad_cast异常类型。
标准库异常类之定义了几种运算，包括穿件或者拷贝异常类型的对象，以及为异常类型的对象赋值。我们只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。
其他异常类型的行为则恰好相反：应该使用stringstring对象或者C风格字符串初始化这些类型的对象，但是不逊于使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。
异常类型之定义了一个名为what的成员函数，该函数没有任何参数，返回值是一个指向C风格字符转的const char*。该字符串的目的是提供关于异常的一些文本信息。
what函数返回的C风格字符串的内容与异常对象的类型有关。如果异常类型有一个字符串初始值，则what返回该字符串。对于其他无初始值的异常类型来说，what返回的内容由编译器决定。

# 函数 #

## 函数基础 ##

### 函数参数 ###

一个函数包括一个形参列表。此列表可以为空但是不能省略。定义空形参列表可以通过书写一个空的形参列表或者使用(std :: void)来实现。形参列表中每个形参都是一个含有声明符的声明，即使两个形参的类型一样，也必须把两个类型都写出来。任意两个形参不能同名，而且函数最外层作用域中的局部变量也不能使用与函数形参一样的名字。
*是否设置未命名的形参并不影响调用时提供的实参数量。即使某个形参不被函数使用，也必须为它提供一个实参。*
形参是一种自动对象。函数开始的时候为形参申请存储空间，因为形参定义在函数体作用域内，所以一旦函数终止，形参也就被销毁。

#### 参数传递 ####

形参的类型决定了形参和实参的交互方式。

1. 如果形参不是引用类型，则将实参的值拷贝后赋给形参。此时形参和实参是两个相互独立的对象。称此类实参被*值传递*或者函数被*传值调用*。

2. 如果形参是引用类型，它将绑定到对应的实参上。引用形参是它绑定实参对象的别名。称对应的实参被*引用传递* 或函数被*传引用调用*。

   当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型对象。如果函数无需改变引用形参的值，最好将其声明为常量引用。

   **一个函数只能返回一个值**，可以通过使用引用形参一次返回多个结果。e.g. 定义一个名为find_char的函数，它返回string对象中某个指定字符第一次出现的位置并同时返回该字符出现的次数。
   通常情况下有两种方法实现以上功能：1）定义一个新的数据类型，让它包含位置和数量两个成员；2）给函数传入一个额外的引用实参，令其保存字符出现的次数。
 ```
   string :: size_type find_char(const string &s, char c, string :: size_type &occurs){
   auto ret = s.size(); // 第一次出现的位置（如果有的话）
   occurs = 0; // 设置表示出现次数的形参的值
   for (decltype(ret) i = 0; i != s.size(); ++i){
	   if (ret == s.size())
		   ret = i; // 记录c第一次出现的位置
	   ++occurs; // 将出现的次数加1
	   }
   }
   return ret; // 出现次数通过occurs隐式地返回
}
 ```

我们通过如下语句调用find_char函数：(std :: auto index = find_char(s, 'o', ctr); )其中s为一个string对象，ctr是一个size_type对象。调用完成后，如果string对象中确实存在o，则ctr就是o出现的次数，index指向o第一次出现的位置；否则，index = s.size( )，ctr = 0。

尽量使用**常量使用**，因为使用引用而非常量引用会极大地限制函数所能接收到的实参类型（我们不能把const对象、字面值或者需要类型转换的对象传递给普通的引用形参）。

##### const形参和实参  #####

当形参为const时，要注意关于顶层const的讨论。使用实参初始化形参时会忽略掉顶层const。
*当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。* 调用fcn函数时既可以传入const int也可以传入int，且其结果可能很怪。
```
void fcn(const int i) {/\* fcn能够读取i，但是不能向i写值。\*/}
void fcn(int i) // X，重复定义了fcn(int)
```
C++允许我们定义若干具有相同名字的函数，不过前提是**不同函数的形参列表应该有明显区别。**

##### 数组形参 #####

由于数组的特殊性质，我们无法以值传递的方式使用数组参数，但是我们可以把形参写成数组的形式：
```
void print(const int*);
void print(const int*[]);
void print(const int*[10]); // 此3种表达式等价
```

如果我们传给print函数一个数组，则实参自动地转换成指向数组首元素的指针。数组大小对函数的调用没有影响。

和其他使用数组的代码一样，以数组作为形参的函数必须确保使用数组时不会越界。 因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切尺寸，调用者应该为此提供一些额外的信息，由此经常使用以下三种方式：
1. **使用标记指定数组的长度：** 此种方法要求数组本身包含一个结束标记。常见案例为C风格字符串。这种方法适用于有明显结束标记且该标记不会与普通数据混淆的情况，但是对于int这样所有取值都合法的数据就不太有效了。
2. **使用标准库规范：** 通过传递指向数组首元素和尾后元素的指针，我们可以依照以下形式输出元素内容：
```
void print(const int *beg, const int *end){
	//输出beg和end之间（不含end）的所有的元素
	while(beg != end){
		cout << *beg ++ << endl;
	}
}
int j[2];
// j转换成指向它首元素的指针
// 第二个实参是指向j的尾后元素的指针
print(begin(j),end(j));
```
3. **显式地传递一个表示数组大小的形参：** 专门定义一个表示数组大小的形参。print函数由此可以重写成以下形式：
```
void print(const int ia[], size_t size){
	for(size_t i = 0; i != size; ++i){
		cout << ia[i] << endl;
	}
}
int j[] = {0,1};
print( j,end(j) - begin(j) );
```

当函数不需要对数组元素执行写操作时，数组形参应该是指向const的指针。只有当函数确实要改变元素的时候，才把形参定义成指向非常量的指针。

形参也可以时数组的引用。此时引用形参绑定到对应的实参上，也就是绑定到数组上：
```
//正确，形参是数组的引用，维度是类型的一部分
void print(int (&arr)[10]){
	for (auto elem : arr){
		cout << elem << endl;
	}
}
```

当将多维数组传递给函数时，真正传递的是指向数组首元素的指针：
```
void print(int (*matrix)[10], int rowSize){
/* ... */
}
```

##### main:处理命令行选项 #####

有时需要给main函数传递实参，一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。

##### 含有可变形参的函数 #####

在无法提前预知应该向函数传递几个实参时，我们需要编写能处理不同数量实参的函数。常用方法有3种：
1. initializer_list形参
   initializer_list定义在同名头文件中。定义initializer_list对象时，必须说明列表中所含元素的类型。e.g. (std :: initializer_list\<int\> li ). initializer_list对象中的元素永远是常量值，我们无法改变initializer_list对象中的元素的值。如果想向initializer_list形参中传递一个值的序列，则必须把序列放在一堆花括号内：
```
// 编写输出错误信息的函数，使其可以作用于可变数量的实参
void error_msg(initializer_list<string> il){
	for (auto beg = il.begin(); beg != il.end(); ++beg)
		cout << *beg << " ";
	cout << endl;
}
// expected和actual是string对象
if(expected != actual)
	error_msg ({"functionX", expected, actual});
else 
	error_msg({"functionX", "okay"});
```
含有intializer_list形参的函数也可以同时拥有其他形参。通过引入ErrCode形参，以上代码可重写为：
```
void error_msg(ErrCode e, initializer_list<string> il){
	cout << e.msg() << ": ";
	for(const auto &elem : i)
		cout << elem << " ";
	cout << endl;
}
if (expected != actual)
	error_msg(ErrCode(43),{"functionX", expected,actual});
else
	error_msg(ErrCode(0),{"functionX","okay"});
```

##### 默认实参 #####

某些函数有这样一种形参，在函数的很多次调用中它们被赋予一个相同的值，此时我们把这个反复出现的值成为函数的默认实参。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。
```
typedef string :: size_type sz;
string screen(sz ht = 24, sz wid = 80, char backgrnd = ' ');
string window;

window = screen(); // 等价于screen(24,80,' ')
window = screen(66); //等价于screen(66,80,' ')
window = screen(66,256);//等价于screen(66,256,' ')
window = screen(66,256,'#'); // 等价于screen(66,256,'#')
```

函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参（靠右侧位置）。**只能省略尾部的实参。** 当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，尽量让不怎么使用默认值的形参出现在前面，而让经常使用默认值的形参出现在后面。

如果函数包含默认实参，则我们在调用该函数时传入的实参数量可以少于形参数量。

### 函数声明 ###

函数声明和函数定义非常类似，只是函数声明无需函数体，用一个分号，替代即可。函数声明应该在头文件中实现，而定义函数的源文件应该把含有函数声明的头文件包含进来，编译器负责验证函数的定义和声明是否匹配。

在给定的作用域中一个形参只能被赋予一次默认形参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须有默认值。
### 局部变量 ###

局部变量仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其他所有声明中。某些时候，有必要令局部变量的生命周期贯穿函数调用及之后的时间。可以将局部变量定义成static类型从而获得这样的对象。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。如果局部静态变量没有显式初始值，它将执行值初始化。内置类型的局部静态变量初始化为0。

*局部变量不能作为默认实参。* 
### 函数返回类型 ###

大多数类型都能用作函数的返回类型。一种特殊的返回类型是void，它表示函数不返回任何值。

函数的返回类型不能是数组类型或者函数类型，但可以是指向数组或者函数的指针。比较直接的方法是实用类型别名。如果不想使用类型别名，我们可以定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也在跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式为：(std :: Type (\*function(parameter_list))\[dimension\])，其中Type表示元素的类型，dimension表示数组的大小，(std :: \(\*function(parameter_list)\))两端的括号必须存在。C++中还可以利用使用尾置返回类型简化以上声明方法。任何函数都可以使用尾置返回，但是这种形式对返回类型比较复杂的函数最有效。尾置返回类型跟在形参列表后面并以一个->符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个auto：
```
// func接受一个int类型的实参，返回一个指针，该指针指向含有10个整数的数组
auto func(int i) -> int (*) [10];
```

还有一种情况，在我们知道函数返回的指针将指向哪个数组时，就可使用decltype关键字声明返回类型。

如果函数的类型不是void，那么它必须返回一个值。但是这条规则有个例外：我们允许main函数没有return语句直接结束。如果控制到达了main函数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句。

返回一个值的方式和初始化一个变量或者形参的方式完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。如果函数返回一个引用，则该引用仅是它所引对象的一个别名。

函数返回通常使用return实现。return语句终止当前正在执行的函数并将控制权返回到调用该函数的位置。return语句通常有两种形式：
1. (std :: return);
2. (std :: return expression);

return语句的返回值的类型必须与函数的返回类型相同，或者能隐式的转换成函数的返回类型。返回类型为void的函数也可以使用return语句的第二种形式，但是此时*return语句中的expression的部分必须是另一个返回void的函数*。强行令void函数返回其他类型的表达式将产生编译错误。

没有返回值的return语句只能用在返回类型是void的函数中。返回void的函数不要求一定有return语句，因为这类函数的最后一句后面会隐式的执行return。

通常情况下，void函数如果想在它的中间位置提前退出，可以使用return语句（类似于break）。
```
void swap(int &v1, int &v2)
{
	if (v1 == v2)
		return; 
	int tmp = v2;
	v2 = v1;
	v1 = tmp;
}
```
*不要返回局部对象的引用和指针*，原因是函数完成后，它所占的存储空间也随之被释放掉。因此函数终止意味着局部变量的引用将指向不再有效的内存区域。同样，返回局部对象的指针也是错误的，一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。

如果返回类型是常量引用，我们不能给调用的结果赋值。

花括号包围的值的列表可以被函数用作返回值，用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型来决定。（接[[|编写输出错误信息的函数，使其可以作用于可变数量的实参]]）

```
// error_msg函数中，返回一个vector对象，用它存放表示错误信息的string对象
vector<string> process(){
	// ...
	// expected和actual是string对象
	if (expected.empty());
		return {}; //返回一个空vector对象
	else if (expected == actual)
		return{"functionX", "okay"} // 返回列表初始化的vector对象
	else 
		return{"functionX", expected, actual};
}
```


### 分离式编译 ###

这里举例阐述系统通过分离式编译实现编译和链接多个源文件的大致过程：

假设fact函数的定义位于一个名为fact.cc的文件中，它的声明位于名为Chapter6.h的头文件中。显然与其他所有用到fact函数的文件一样，fact.cc应该包含Chapter6.h头文件。
我们在名为factMain.cc的文件中创建main函数，main函数将调用fact函数。要生成可执行文件，必须告诉编译器我们用到的代码在哪里。实现代码如下：
```
$ CC factMain.cc fact.cc # generates factMain.exe or a.out
$ CC factMain.cc fact.cc -o main # generates main or main.exe
```
其中CC是编译器的名字，$是系统提示符，#后面是命令行下的注释语句。接下来运行可执行文件，就会执行我们定义的main函数。

如果我们修改了其中一个源文件，那么只需要重新编译那个改动了的文件。大多数编译器提供了分离式比阿姨每个文件的机制，这一过程通常会产生一个后缀名是(std :: .obj)(Windows)或者(std :: .○)(Unix)的文件，后缀名的含义是该文件包含对象代码。

接下来编译器负责把对象文件链接在一起形成可执行文件。e.g.：
```
$ CC -c factMain.cc # generates factMain.o
$ CC -c fact.cc # generates fact.o
$ CC factMain.o fact.o # generates factMain.exe or a.out
$ CC factMain.o fact.o -o main # generates main or main.exe
```

## 函数重载 ##

如果同一个作用域内的几个函数名字相同但是形参列表不同，我们称之为重载函数。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。*main函数不能重载。* 不同作用域中无法重载函数名。对于重载的函数来说，它们应该在形参数量或者形参类型上有所不同。**不允许两个函数除了返回类型外其他所有的要素相同。**

顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。如果形参是某种类型的指针的引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层。【需要注意const_cast的使用】

定义了一组重载函数以后，我们可以通过把函数调用与一组重载函数中的某一个关联起来的**函数匹配**的过程来合理调用实参，函数匹配也叫做重载确定。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。
当调用重载函数时有三种可能的结果：
1. 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码
2. 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。
3. 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误成为二义性调用。

函数匹配/函数重载一般分三步完成：

1. 选定本次调用对应的重载函数集，集合中的函数为候选函数。
   候选函数具有两个特征：1）与被调用函数同名 2）其声明在调用点可见
2. 考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为可行函数。如果没有找到可行函数，编译器将报告无匹配函数的错误。
   为了确定最佳匹配，编译器将实参类型到形参类型的转换划分成几个等级，具体排序如下所示：1）精确匹配，包括：实参类型和形参类型相同；实参从数组类型或者函数类型转换成对应的指针类型；向实参添加顶层const或者从实参中删除顶层const。2）通过const转换实现的匹配。3）通过类型提升实现的匹配。4）通过算数类型转换或者指针转换实现的匹配。5）通过类类型转换实现的匹配。
   可行函数也具有两个特征：1）形参数量与本次调用提供的实参数量相等 2）每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。
3. 从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数。其基本思想是，实参类型与形参类型越接近，它们匹配的越好。

如果定义了重载函数的指针，编译器通过指针决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配。
## 函数优化 ##

### 内联函数及constexpr函数 ###

在大多数极其上，一次函数调用其实也包含着一系列工作：调用前要先保存寄存器，并在返回时恢复：可能需要拷贝实参；程序转向一个新的位置继续执行。可以使用关键词inline将函数声明为内联函数，从而避免函数调用的开销。一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且过于复杂的函数也不太可能在调用点内联地展开。

constexpr函数可以被隐式的指定为内联函数，其本身指的是可以用于常量表达式的函数。定义constexpr函数时需要遵循几项约定：函数的返回类型以及所有形参的类型都是字面值类型，且函数体中必须有且只有一条return语句。

和其他函数不一样，内联函数以及constexpr函数可以在程序中多次定义。不过对于某个给行的内联函数或者constexpr函数来说，它的多个定义必须完全一致。由此内联函数以及constexpr函数经常被定义在头文件里。
### 调试帮助 ###

程序可以包含一些用于调试的代码，但是这些代码只在开发程序时使用。当应用程序编写完成准备发布时，要先屏蔽掉调试代码。这种方法用到两项预处理功能：assert和NDEBUG。

assert是一种预处理宏（一种预处理变量），使用一个表达式作为它的条件：(std :: assert(expr))来检查某种“事件”发生与否。首先对expr求值，如果表达式为0，则assert输出信息并终止程序的执行。如果表达式为1，则assert什么也不做。assert宏定义在cassert头文件中。我们应该直接使用assert而不需要对它进行声明。
```
assert(word.size()>threshold);
```

assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG，则assert什么也不做。默认状态下NDEBUG没有被定义，此时assert将执行运行时检查。可以使用(std :: \#define)来定义NDEBUG从而关闭调试状态或者使用很多编译器都会提供的命令行选项对NDEBUG进行定义。

除了assert外, NEDBUG也可以用于编写自己的条件调试代码。C++提供了一部分对于程序调用很有用的名字（详情参见Documentation）。

### 函数指针 ###

函数指针指向的是函数而非对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回类型和形参类型共同决定，与函数名无关。
当我们把函数名作为一个值使用时，该函数自动地转换成指针。我们还可以直接使用指向函数的指针调用该函数，无需提前解引用指针。
*在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们可以为函数指针赋一个nullptr或者值为0的整型常量表达式，表示该指针没有指向任何一个函数。*

虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。我们可以直接把函数作为实参使用，此时它会自动转换成指针。类型别名和decltype能让我们简化使用。需要注意的是**decltype返回函数类型，此时不会将函数类型自动转换为指针类型。只有在前面加上\*才能得到指针。** 虽然不能返回一个函数，但是能返回指向函数类型的指针。然而，我们必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理。可以通过类型别名或者显式指定返回类型为指针实现。也可以使用尾置返回类型的方式声明一个返回函数之神的函数。

# 类 #

类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程（以及设计）技术。类的接口包括用户所能执行的操作；类的实现则包括类的数据成员、负责接口实现的函数体以及定义类所需的各种私有函数。

封装有两个优点：
1. 确保用于代码不会无意间破坏封装对象的状态；
2. 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码。

## 成员函数 ##

定义和声明成员函数的方式与普通函数差不多。成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部。作为接口组成部分的非成员函数，它们的定义和声明都在类的外部。定义在类的内部的函数是隐式的inline函数。当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，返回类型、参数列表和函数名都得与类内部的声明保持一致。如果成员被声明称常量成员函数，那么它的定义也必须在参数列表后明确指定const属性。同时，类外部定义的成员的名字必须包含它所属的类名。e.g.:
```
double Sales_data :: avg_price() const {
	if (units_sole)
		return revenue/units_sold;
	else 
		return 0;
}
```

这里Sales_data :: avg_price使用了作用域运算符来说明如下的事实：我们定义了一个名为avg_price的函数，并且该函数被声明在类Sales_data的作用域内。一旦编译器看到这个函数名，就能理解剩余的代码是位于类的作用域内的。因此，当avg_price使用revenue和units_sold时，实际上它隐式的使用了Sales_data成员。

当我们调用成员函数时，实际上是替某个对象调用它。成员函数通过一个名为this的额外的隐式参数来访问调用它的那个对象。当我们用一个成员函数时，用请求该函数的对象地址初始化this。在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无需通过成员访问运算符来做到这一点，因为this所指的正是这个对象。任何对类成员的直接访问都被看做是对this的隐式引用。不过要注意，*任何自定义名为this的参数或变量的行为都是非法的。* 默认情况下，this的类型是指向类类型非常量版本的常量指针。不过可以通过在参数列表后加上关键词const来表示this是一个指向常量的指针，这种使用const的成员函数被称作常量成员函数。我们无需使用隐式的this指针访问函数调用者的某个具体成员，而是需要把调用函数的对象当成一个整体来访问：(std :: return \*this;)。

编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此成员函数体可以随意使用类中的其他成员而无需在意这些成员出现的次序。

如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件中。

### 构造函数 ###

每个类都分别定义了它的对象被初始化的方式，类通过一个或者多个特殊的成员函数来控制器对象的初始化过程，这些函数被叫做构造函数。

构造函数的名字和类名相同。和其他函数不一样的是，构造函数没有返回类型；除此以外类似于其他的函数，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或者参数类型上有所区别。

构造函数不能被声明为const的。当我们构建类的一个const对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在const对象的构造过程中可以向其写值。

类可以通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做默认构造函数。默认构造函数无需任何参数。如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。编译器创建的构造函数又被称为合成的默认构造函数。对于大多数类莱索，这个合成的默认构造函数将按照如下规则初始化类的数据成员：
1. 如果存在类内的初始值，用它来初始化成员。
2. 否则，默认初始化该成员。

但是合成的默认构造函数只适合非常简单的类，对于一个普通的类来说，必须定义它自己的默认构造函数，原因如下：
1. 编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类没有默认构造函数。
2. 对于某些类来说，合成的默认构造函数可能执行错误的条件。
3. 有的时候编译器不能为某些类合成默认的构造函数。

在C++新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面加上(std :: = default)来要求编译器生成构造函数。其中，(std :: = default)既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他的函数一样，如果(std :: = default)在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的。如果你的编译器不支持类内初始值，那么你的默认构造函数就应该使用**构造函数初始值列表**来初始化类的每个成员。它是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内）成员初始值，不同成员的初始化通过都好分隔开来。负责为新创建的对象的一个或者几个数据成员赋初值。如果你不能使用类内初始值，则所有的构造函数都应该显式地初始化每个内置类型的成员。

## 访问控制和封装 ##

C++中，我们使用访问说明符加强类的封装性。一个类可以包含0个或者多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。每个访问说明符指定了接下来的成员的访问级别，其有效范围知道出现下一个访问说明符或者到达类的结尾处为止。

我们可以使用struct和class进行类的定义，这两者的默认访问权限不太一样。如果我们使用struct关键字，则定义在第一个访问说明符之前的成员是public的；相反如果使用class,则是private的。

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数称为它的友元。如果类想把一个函数作为它的友元，只需要增加一条以friend关键字开始的函数声明语句即可。友元的声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员，也不受它所在区域访问控制级别的约束。友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。为了使友元对类的用户可见，我们通常把友元的声明与类的本身放置在同一个头文件中（类的外部）。