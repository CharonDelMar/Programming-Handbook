## Introduction ##
C++语言可以看作是三部分构成：低级语言、现代高级语言（允许我们定义自己的类型以及组织大规模程序和系统）、标准库（利用高级特性来提供有用的数据结构和算法）。

一个或多个函数 , 其中一个必须命名为 *main.* *main* 的返回值类型必须为 *int*, 一般被用于指示程序运行状态，返回值0代表成功，非0通常用于指示错误类型。

函数定义包含四个部分：return type, function name, parameter list & function body.

运行VS编译器命令：
系统提示符> c1 /编译器选项 源文件名
e.g. (std::C:\\Users\\me\\Programs>c1 /EHsc prog1.cpp)

C++是一种静态类型语言，其含义是*在编译阶段检查类型*。

通常情况下，C++的缩进格式不会影响程序的语义。

C++ 中，一个表达式产生一个运算结果，它由一个或多个运算对象和（通常情况下）一个运算符组成。

C++利用一个标准库来提供io机制。

**iostream library**

One *istream* object：cin (pron: see-in) 标准输入语法
Three *ostream* object：cout (pron: see-out) 标准输出语法、cerr 输出警告和错误消息、clog 输出程序运行时的一般信息

*IO操作一般只作用于当前运行窗口*

\>> 输入运算符 \<< 输出运算符

标准库定义的所有名字都在命名空间std中。*命名空间你可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突*，:: 为作用运算符来指名使用命令所在的命名空间。e.g. cout和endl定义在名为std的命名空间，所以调用时一般使用std : : cout和std : : endl。
>endl为一个被称为manipulator的特殊值，写入endl的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。**缓冲刷新操作可以保证到目前为止程序所产生的扫有输出都真正写入输出流中，而不是进停留在内存中等待写入流。**
  >>*程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。*


Comments: 单行注释 //    多行注释  /* \*/

循环结构：while for
使用一个*istream*对象作为条件时，其效果是**检测流的状态**。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符*end-of-file*，或者遇到一个无效输入时，*istream*对象的状态会变为无效。处于无效状态的*istream*对象会使条件变为假。
其应用形式类似于：(std:: while ( std : : cin >> value ))
>对于Windows系统，从键盘输入文件结束符的方式为 (std:: Ctrl +Z )
>对于macOX系统，从键盘输入文件结束符的方式为 (std:: Ctrl +D)

### Datatype (More Details in **Data Structure** ) ###

*当明确知晓数值不可能为负时，选用无符号类型*
*执行浮点数运算选用double*
*当一个算数表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。从无符号数中减去一个值时，我们要保证结果不可能为负。*

关于一些强行类型转换：
>非布尔类型的算数值 >> bool：初始值为0则结果为false，否则结果为true。
>bool >> 非布尔类型：初始值为false则结果为0, 初始值为true则结果为1。
>浮点数 >> int：结果仅保留小数点以前的部分。
>int >> 浮点数：小数部分记为0。若int所占空间超过浮点数则可能损失精度。
>unsigned >> 超出其表示范围的值，结果是初始值对无符号类型表示数值总数**取模**后的余数
>signed >> 超出其表示范围的值，结果未知，程序可能正常工作/崩溃/生成垃圾数据。

如果两个字符串字面值位置紧邻且仅有空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式，e.g.：
(std:: std : : cout << "a really, really long string literal")
                 (std:: "that spans two lines" << std : : endl; )

C++可以通过给字面值字符添加前后缀指定字面值类型；

转义字符（详见C++ documentation --> escape sequence）

## Variables ###

*初始化不是赋值！！！初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，然后用一个新值来代替。*

#### Initialisation ####

C++定义了多种初始化形式。

#### 列表初始化 ####

使用花括号初始化变量，e.g. (std:: int units_sold{0};)

 *当用于内置类型的变量时，如果我们使用列表初始化且存在丢失信息的风险，则编译器将报错。*
```
long double ld = 3.1415936;
int a{ld}, b = {ld};
int c(ld), d = ld;
```

#### 默认初始化 ####

如果定义变量时没有指定初始值，则变量被默认初始化，此时变量被赋予了default value。default value到底是什么由变量类型决定并受到定义变量的位置的影响。
如果是内置类型变量未被初始化，它的值一般由定义的位置决定。但是 *定义在函数体内部的内置类型变量将不被初始化。如果试图拷贝或以其他形式访问此类型将引发错误。*

每个类各自决定其初始化对象的方式，而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么 （*类的对象如果没有显式初始化，则其类型由类本身决定。*）。
绝大多数类都支持无须显式初始化而定义对象。
e.g.: (std:: std : : string empty // empty 非显式地初始化为一个空串。)
若不支持此功能的类的对象没有进行显式初始化，则程序会报错。

#### Declaration  & Definition ####

声明规定了变量的类型和名字；
定义规定了变量的类型和名字，申请存储空间，还可能为变量赋一个初值。

*如果想声明一个变量而不是定义它，需要使用 extern，且 **不要显式地初始化变量！！！*** 
```
extern int i; \\ Declaration
int j; \\ Definition
extern int k = 1; \\ Definition
```

*变量能且只能被定义一次，但可以被多次声明。* 如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现且只能出现在同一个文件中，而其他使用该变量的文件必须对其进行声明，**却决不能重复定义** 。

#### 作用域 Scope ####

```
int reused = 42; \\ [A] --> global scope
int main(){

	int unique = 0; 
	std :: cout << reused << " " << unique << std :: endl; \\ output1: 42 0
	
	int reused = 0; \\ [B] --> block scope
	std :: cout << reused << " " << unique << std :: endl; \\ output2: 0 0
	
	std : : cout << : : reused << unique << std : : endl; \\ output3: 42 0
	
	return 0;
}
```
output1输出全局变量reused的值；
语句【B】新建了局部变量reused。所以，对于output2，由于新建的局部变量reused正在作用域内，其输出为局部变量reused的值；
output3 使用作用域操作符 : : 来覆盖默认的作用域规则，*因为全局作用域本身没有名字，所以 **当作用域操作符左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量***。结果是，output3输出了全局变量reused的值。
故，若可能用到某全局变量，则不宜再定义一个同名的局部变量。

### 复合类型 ###

**引用 (reference)** 为对象起了另一个名字，即别名。通过(std :: &d) 实现。
```
int ival = 1;
int &refVal = ival;
```

**指针**也可以实现对其他对象的间接访问。使用(std:: \*d)作为声明符定义指针类型，e.g. (std :: int \*ip1)；使用(std :: &d) 来获取对象（std :: d）的地址，并可以将其放置于指针中存储，e.g. (std :: int \*p = &ival )。
指针与引用相比有所不同：
1. 指针本身是一个对象，允许对指针进行赋值和拷贝。
2. 指针可以先后指向几个不同的对象。
3. 指针无需再定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

*要注意，在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以两者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。*

在使用一个指针之前，代码最好检查它是否为空。可以使用(std :: nullptr)来初始化指针，或者将指针赋值为0。

**一个指针指向某对象，同时另一个指针指向另外对象的下一个地址，此时可能出现这两个指针值相同的情况，即指针相等。***

(std :: \*void)可以存放任意对象地址，但是并不了解其中对象类型。

**指针可以指向指针；引用不为对象，故指针无法指向引用，但是指针是对象，故存在对指针的引用。**

### const限定符 ###

const可以用作限定符使变量的值不被改变。其使用形式大致如下：
						(std :: const int bufSize = 512;)

默认状态下，const对象仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定义了独立的变量。*如果想实现，只在一个文件中定义const，而在其他多个文件中声明并使用它的功能，解决的办法是：*
	对于const变量不管是声明还是定义都添加extern关键字，这样只需定义一次就可以了：
		                 (std :: extern const int bufSize = fcn();)

在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。当一个常量引用被绑定到另外的一种类型上时，
```
double dval = 3.14 ;
const int &ri = dval;
```
此处(std :: ri)引用了一个int型的数。对(std :: ri)的操作应该是整数运算，但dval却是一个双精度浮点数而非整数。因此为了确保让(std :: ri)绑定一个整数，编译器把上述代码变成了如下形式，
```
const int temp = dval; // 由双精度浮点数生成一个临时的整型常量
const int &ri = temp; //让ri绑定这个临时量
```
由于基本大家不会将引用绑定到临时量上，C++语言会把这种行为归为非法。

#### 顶层/底层指针 ####

**顶层指针 -- > 常量指针**

顶层指针必须初始化，而且一旦初始化完成，它的值（即存放于指针中的地址就不能再改变）。此功能由(std :: \*const d)实现，e.g. (std :: int \*const curErr = &errNumb;)。

**底层指针 --> 指向常量的指针**

*底层指针不能用于改变其所指对象的值，可以存放常量对象的地址。* 多数情况下，指针的类型必须与其所指对象的类型一致，但是底层指针为其中一种例外情况，允许底层指针指向一个非常量对象：
```
const double pi = 3.14;
double *ptr = &pi;
const double  *cptr = &pi;
*cptr = 42;
double dval = 3.14;
cptr = &dval;
```

**在执行对象的拷贝操作时，常量是顶层const还是底层const区别明显。** 其中顶层const不受什么影响，但是对底层const却存在不可忽视的限制。当执行对象的拷贝操作时，拷贝对象必须有相同的底层const资格，或者两个对象的数据类型必须能转换。一般来说，非常量可以转换成常量，反之则不行。

C++允许将变量声明为 (std :: constexpr ) 类型以便由编译器来验证变量的值是否是一个常量表达式(const expression)。
\[所谓常量表达式指的是值不会改变且在编译过程就能得到计算结果的表达式\] 
*声明constexpr时用到的类型一般比较简单，一般成为“字面值类型”。* 另外在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效，与指针所指的对象无关。

### 处理类型 ###

**类型别名**：有两种方法可用于定义类型别名。
```
typedef double wages; // wages是double的同义词
using SI = Sales_item; //SI是Sales_item的同义词
```

**auto**：让编译器通过初始值来推算变量的类型，从而去替我们去分析表达式所属的类型。故auto定义的变量必须有初始值：
```
//由val1和val2相加的结果可以推断出item变量
auto item = val1 + val2; //item初始化为val1和val2相加的结果
```
**decltype**：选择并返回操作数的数据类型。在此过程中，*编译器分析表达式并得到它的类型，却不实际计算表达式的值*。
```
decltype (f()) sum = x; // sum 的类型就是函数f的返回类型。
```

**要注意以上类型指示符在复合类型及常量相关结构中的使用**

编译器推断出来的auto类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。
1. 编译器以引用类型作为auto的类型。
2. auto一般会忽略掉顶层const，同时底层const则会保留下来：
```
const int ci = i, &cr = ci;
auto b = ci; // b是一个整数 (ci的顶层const特性被忽略掉了)
auto c = cr; // c是一个整数(cr是ci的别名，ci本身是一个顶层const)
auto d = &i; // d是一个整型指针(整数的地址就是指向整数的指针)
auto e = &ci; // e是一个指向整数常量的指针(对常量对象取地址是一种底层const)
```
如果希望推断出的auto类型是一个底层const，***需要明确指出***
```
const auto f = ci; // ci的推演类型是int，f是const int
```
还可以将引用的类型设为auto，此时原来的额初始化规则仍然适用：
```
auto &g = ci; // g是一个整型常量引用，绑定到ci
auto &h = 42; // 错误： 不能为非常量引用绑定字面值
const auto &j = 42; // 正确：可以为常量引用绑定字面值
```
设置一个类型为auto的引用时，初始值种的顶层常量属性仍然保留。注意，当我们给初始值绑定一个引用时，此时的常量就不再是顶层常量了。

decltype处理顶层const和引用的方式与auto有些许不同。
1. 如果decltype使用的表达式是一个变量，那么decltype返回该变量的类型（包括const 和引用在内），如果表达式的内容是解引用操作，则decltype将得到引用类型。e.g. (std :: decltype(\*p))的结果为(std :: int&)而不是(std :: int)：
```
const int ci = 0, &cj = ci;
decltype(ci) x = 0; // x的类型是const int
decltype(cj) y = x; // y的类型是const int&,y绑定到x
decltype(cj) z; //错误，z为引用需要初始化
```
2. decltype的结果类型与表达式形式密切相关。*对于decltype所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有些许不同。* 如果使用的为不加括号的变量，则得到该变量的类型；如果加了一层或者多层括号，编译器会将其按照表达式处理。***注意，decltype((variable))的结果永远是引用，而单层括号结果只有当变量本身为引用时才是引用。***

### 特殊数据结构简述 ###

一个简单的样例：
```
struct Sales_data {
	std :: string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
}; // 记得在类定义后加分号
```

以上类Sales_data只有数据成员，故可以使用类内初始值进行初始化（没有初始值的数据成员将被默认初始化）。

*除了struct，可以使用class定义类*

为了确保在各个文件中的类的定义一致，类通常被定义在头文件中，而且类所在的头文件的名字应与类的名字保持一致。另,程序员有必要在书写头文件时做适当的处理，使其遇到多次包含的情况也能安全和正常地工作。其常用的技术为预处理器(preprocessor)。C++会用到的一项预处理功能为头文件保护符。头文件保护符依赖于预处理变量：(std :: \#define)指令将一个名字设置为预处理变量，(std :: \#ifedf)当且仅当变量已定义时为真；(std :: \#ifnedf)当且仅当变量未定义时为真，一旦结果检验为真，则执行后续操作直到(std :: \#endif)指令为止。
```
#ifndef SALES_DATA_H
#define SALES_DATA_H
#include <string>
struct Sales_data {
	std :: string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
#endif
```
*整个程序中的预处理变量包括头文件保护符必须唯一，通常的做法是基于头文件中类的名字来构建保护符的名字，以确保其唯一性。为了避免与程序中的其他实体发生名字冲突，一般吧处理变量的名字全大写。*



## 各种串串 ##

