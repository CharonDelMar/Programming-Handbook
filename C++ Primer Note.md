## Introduction ##
C++语言可以看作是三部分构成：低级语言、现代高级语言（允许我们定义自己的类型以及组织大规模程序和系统）、标准库（利用高级特性来提供有用的数据结构和算法）。

一个或多个函数 , 其中一个必须命名为 *main.* *main* 的返回值类型必须为 *int*, 一般被用于指示程序运行状态，返回值0代表成功，非0通常用于指示错误类型。

函数定义包含四个部分：return type, function name, parameter list & function body.

运行VS编译器命令：
系统提示符> c1 /编译器选项 源文件名
e.g. (std::C:\\Users\\me\\Programs>c1 /EHsc prog1.cpp)

C++是一种静态类型语言，其含义是*在编译阶段检查类型*。

通常情况下，C++的缩进格式不会影响程序的语义。

C++ 中，一个表达式产生一个运算结果，它由一个或多个运算对象和（通常情况下）一个运算符组成。

C++利用一个标准库来提供io机制。

**iostream library**

One *istream* object：cin (pron: see-in) 标准输入语法
Three *ostream* object：cout (pron: see-out) 标准输出语法、cerr 输出警告和错误消息、clog 输出程序运行时的一般信息

*IO操作一般只作用于当前运行窗口*

\>> 输入运算符 \<< 输出运算符

标准库定义的所有名字都在命名空间std中。*命名空间你可以帮助我们避免不经意的名字定义冲突，以及使用库中相同名字导致的冲突*，:: 为作用运算符来指名使用命令所在的命名空间。e.g. cout和endl定义在名为std的命名空间，所以调用时一般使用std : : cout和std : : endl。
>endl为一个被称为manipulator的特殊值，写入endl的效果是结束当前行，并将与设备关联的缓冲区中的内容刷到设备中。**缓冲刷新操作可以保证到目前为止程序所产生的扫有输出都真正写入输出流中，而不是进停留在内存中等待写入流。**
  >>*程序员常常在调试时添加打印语句。这类语句应该保证“一直”刷新流。否则，如果程序崩溃，输出可能还留在缓冲区中，从而导致关于程序崩溃位置的错误推断。*


Comments: 单行注释 //    多行注释  /* \*/

循环结构：while for
使用一个*istream*对象作为条件时，其效果是**检测流的状态**。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符*end-of-file*，或者遇到一个无效输入时，*istream*对象的状态会变为无效。处于无效状态的*istream*对象会使条件变为假。
其应用形式类似于：(std:: while ( std : : cin >> value ))
>对于Windows系统，从键盘输入文件结束符的方式为 (std:: Ctrl +Z )
>对于macOX系统，从键盘输入文件结束符的方式为 (std:: Ctrl +D)

### Datatype (More Detials in **Data Structure** )###

*当明确知晓数值不可能为负时，选用无符号类型*
*执行浮点数运算选用double*
*当一个算数表达式中既有无符号数又有int值时，那个int值就会转换成无符号数。从无符号数中减去一个值时，我们要保证结果不可能为负。*

关于一些强行类型转换：
>非布尔类型的算数值 >> bool：初始值为0则结果为false，否则结果为true。
>bool >> 非布尔类型：初始值为false则结果为0, 初始值为true则结果为1。
>浮点数 >> int：结果仅保留小数点以前的部分。
>int >> 浮点数：小数部分记为0。若int所占空间超过浮点数则可能损失精度。
>unsigned >> 超出其表示范围的值，结果是初始值对无符号类型表示数值总数**取模**后的余数
>signed >> 超出其表示范围的值，结果未知，程序可能正常工作/崩溃/生成垃圾数据。

如果两个字符串字面值位置紧邻且仅有空格、缩进和换行符分隔，则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里不太合适时，就可以采取分开书写的方式，e.g.：
(std:: std : : cout << "a really, really long string literal")
                 (std:: "that spans two lines" << std : : endl; )

C++可以通过给字面值字符添加前后缀指定字面值类型；

转义字符（详见C++ documentation --> escape sequence）

### Variables ###

*初始化不是赋值！！！初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，然后用一个新值来代替。*

#### Initialisation ####

C++定义了多种初始化形式。

#### 列表初始化 ####

使用花括号初始化变量，e.g. (std:: int units_sold{0};)

 *当用于内置类型的变量时，如果我们使用列表初始化且存在丢失信息的风险，则编译器将报错。*
```
long double ld = 3.1415936;
int a{ld}, b = {ld};
int c(ld), d = ld;
```

#### 默认初始化 ####

如果定义变量时没有指定初始值，则变量被默认初始化，此时变量被赋予了default value。default value到底是什么由变量类型决定并受到定义变量的位置的影响。
如果是内置类型变量未被初始化，它的值一般由定义的位置决定。但是 *定义在函数体内部的内置类型变量将不被初始化。如果试图拷贝或以其他形式访问此类型将引发错误。*

每个类各自决定其初始化对象的方式，而且，是否允许不经初始化就定义对象也由类自己决定。如果类允许这种行为，它将决定对象的初始值到底是什么 （*类的对象如果没有显式初始化，则其类型由类本身决定。*）。
绝大多数类都支持无须显式初始化而定义对象。
e.g.: (std:: std : : string empty // empty 非显式地初始化为一个空串。)
若不支持此功能的类的对象没有进行显式初始化，则程序会报错。

#### Declaration  & Definition ####

声明规定了变量的类型和名字；
定义规定了变量的类型和名字，申请存储空间，还可能为变量赋一个初值。

*如果想声明一个变量而不是定义它，需要使用 extern，且 **不要显式地初始化变量！！！*** 
```
extern int i; \\ Declaration
int j; \\ Definition
extern int k = 1; \\ Definition
```

*变量能且只能被定义一次，但可以被多次声明。* 如果要在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现且只能出现在同一个文件中，而其他使用该变量的文件必须对其进行声明，**却决不能重复定义** 。

#### 作用域 Scope ####

```
...
int reused = 42; \\ [A] --> global scope
int main(){

	int unique = 0; 
	std :: cout << reused << " " << unique << std :: endl; \\ output1: 42 0
	
	int reused = 0; \\ [B] --> block scope
	std :: cout << reused << " " << unique << std :: endl; \\ output2: 0 0
	
	std : : cout << : : reused << unique << std : : endl; \\ output3: 42 0
	
	return 0;
}
```
output1输出全局变量reused的值；
语句【B】新建了局部变量reused。所以，对于output2，由于新建的局部变量reused正在作用域内，其输出为局部变量reused的值；
output3 使用作用域操作符 : : 来覆盖默认的作用域规则，*因为全局作用域本身没有名字，所以 **当作用域操作符左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量***。结果是，output3输出了全局变量reused的值。
故，若可能用到某全局变量，则不宜再定义一个同名的局部变量。

### 复合类型###

**引用 (reference)** 为对象起了另一个名字，即别名。通过(std :: &d) 实现。
```
int ival = 1;
int &refVal = ival;
```

**指针**也可以实现对其他对象的间接访问。使用(std:: \*d)作为声明符定义指针类型，e.g. (std :: int \*ip1)；使用(std :: &d) 来获取对象（std :: d）的地址，并可以将其放置于指针中存储，e.g. (std :: int \*p = &ival )。
指针与引用相比有所不同：
1. 指针本身是一个对象，允许对指针进行赋值和拷贝。
2. 指针可以先后指向几个不同的对象。
3. 指针无需再定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

*要注意，在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以两者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。*

在使用一个指针之前，代码最好检查它是否为空。可以使用(std :: nullptr)来初始化指针，或者将指针赋值为0。

**一个指针指向某对象，同时另一个指针指向另外对象的下一个地址，此时可能出现这两个指针值相同的情况，即指针相等。***

(std :: \*void)可以存放任意对象地址，但是并不了解其中对象类型。

**指针可以指向指针；引用不为对象，故指针无法指向引用，但是指针是对象，故存在对指针的引用。**

